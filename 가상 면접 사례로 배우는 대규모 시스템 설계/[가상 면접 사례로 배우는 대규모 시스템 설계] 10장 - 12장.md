# 10장 알림 시스템 설계

알림 시스템은 다양한 분야에서 많이 쓰이는 기능이다.

모바일 푸쉬알림부터, sms 메시지, 이메일 그리고 긴급재난문자 같은 필수 알림까지 이러한 알림시스템을 어떻게 구축하는지 알아보자.

## 다양한 알림 구현

### 모바일 알림 구현

모바일에서 알림은 다음과 같은 순서로 구현된다.

1. 알림 제공자가 API 호출
2. APNS(Apple Push Notification Service) or FCM(Firebase clouding message)에서 알림 전송
3. 단말에서 알림 확인

알림 전송 API는 보통 사용하는 서비스의 문서에서 제공하기에 해당 스펙에 맞추어 제작한다.

### SMS 메시지

플로우는 모바일과 동일하되 트윌리오, 넥스모와 같은 제 3자 문자 전송 서비스를 이용해야 한다.

### 이메일

고유 이메일 서버를 구축할 수도 있지만, 외부 메일 서버를 이용할 수도 있다.

---

> 사내 SNS, SMS 전송 서비스를 구축하여 사용할 수도  있다.


## 시스템 설계안

기본적으로 알림을 전송하는 제3자 서비스가 필요하고, 각각의 어플리케이션은 이 서비스에 요청을 보내야 한다.

**이에 따라 각 서비스는 SPOF, 병목, 에러시 복구 문제가 발생할 수 있다.**

이를 해결하기 위해 몇가지 방법이 있다.

- 데이터베이스와 캐시를 알림 시스템 서버에 적용
- 알림 서버를 증설하고 분산 시스템으로 구축한다.
- 메시지 큐를 이용해 시스템 컴포넌트를 관리한다.

몇 가지 방법이라 적었지만 보통의 상황에서는 이 모든 방법을 활용하여 알림서버를 설계한다.

### 알림 서비스 요구 사항

알림 전송 시스템 요구사항은 다음과 같을 수 있다.

1. 어떠한 상황에서도 알림이 소실되면 안 될수도 있다. 
2. 알림이 중복되면 안 될 수도 있다.

어디서 많이 본 상황들이지 않은가? 이는 메시지 큐에서 모두 내부메커니즘 적으로 구현되어 있는 요구 사항들이다. 따라서 이러한 설정은 `래빗MQ`, `카프카`에게 위임하고 서버 개발자라면 비즈니스 로직에 집중하자.

> `카프카의 무조건 한번`, `적어도 한번`과 같은전송되는 설정을 활용하라.
>
> [카프카의 신뢰성있는 전달](https://velog.io/@cksgodl/%EC%B9%B4%ED%94%84%EC%B9%B4-%ED%95%B5%EC%8B%AC-%EA%B0%80%EC%9D%B4%EB%93%9C-Chapter-07.-%EC%8B%A0%EB%A2%B0%EC%84%B1-%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EB%8B%AC)을 참고

이들은 책에서 제공하는 전송률 제한, 재시도 방법등의 모든 방법을 제공하며, 메시지 큐를 모니터링 하기 위해서는 카프카 랙을 모니터링하라.

### 알림 이벤트 추적

알림 이벤트를 추적하기 위해서는 알림을 클릭했을 때, 조회했을 때, 상품을 구매했을 때 등의 링크를 딥링크와 같은 형식으로 제공하여, 사용자의 행동을 분석할 수 있다.

이러한 데이터 분석 시스템은 신뢰성이 보장되지 않은 메시지 큐로 관리되어야 할 것이며, 대규모 데이터 처리를 위한 인프라가 구성되어야 한다.

## 요약

알림 메시지서비스에서 중요한건 다음과 같다.

- 안정성
- 이벤트 추적 및 모니터링
- 사용자 알림 수신 설정
- 전송률 제한

이는 알림 서비스지만 메시지 큐를 적극적으로 이용하면 모두 해결되는 문제이다.

# 11장 뉴스 피드 시스템 설계

뉴스피드란 홈 페이지 중앙에 뜨는 지속적으로 업데이트되는 홈페이지, 스토리, 앱 활동 등이 있다.

## 계락적인 설계안

인스타그램의 경우 친구들이 올린 스토리(피드)는 맨위에서 보여줘야하고, 그 다음은 팔로잉 중인 피드, 그다음은 관심있는 주제의 피드를 보여줘야한다.

### 친구피드를 상단에서 보기

이를 구현하기 위해서는 친구가 포스팅을 올릴 때 해당 포스팅을 모든 사용자의 데이터베이스에 전달해야 한다. (팬아웃)

#### 장점 

- 뉴스 피드가 실시간으로 갱신되며, 친구 목록에 있는 사용자에게 바로 알림이 갈 수 있다.
- 새 포스팅이 기록되는 순간 피드가 갱신되므로, 피드를 읽는 데 시간이 줄어든다. (TTL이 짧다.)

#### 단점

- 친구가 많은 사용자의 경우 핫키 문제가 생긴다.
- 서비스를 자주 이용하지 않는 사용자의 피드까지 갱신해야 한다.

---

이와 반대로 피드를 읽어야 하는 시점에 뉴스 피드를 갱신하는 요청 기반(on-Demand)모델이 존재한다.

#### 장점

- 거의 로그인하지 않는 사용자의 경우에 이 모델이 유리하다.
- 데이터를 친구 각각에 푸시하는 작업이 필요없다.(핫키 X)

#### 단점

- 뉴스 피드를 읽는데 로딩시간이 길다.

---

> 대부분의 서비스의 경우는 팬아웃 방식을 활용해 알림을 보내며, 뉴스 피드를 빠르게 불러온다. 

팔로워가 많은 사용자의 경우 팔로워로 하여금 해당 사용자의 포스팅을 필요로 할 때 가져오도록 풀 모델을 사용하여 과부화를 방지한다.

## 상세 구현

1. 그래프 데이터베이스를 활용해 친구 ID목록을 관리한다. (이는 친구 관계나 친구 추천을 관리하기 적합하다.)
2. 사용자 정보 캐시에 친구들의 정보를 저장한다. 이 때 인플루언서나, 뮤트한 사용자는 걸러낸다.)
3. 친구 목록과 새 스토리의 포스팅 ID를 메시지 큐에 넣는다.
4. 메시지 큐에서 데이터를 꺼내어 읽어 뉴스 피드 데이터를 뉴스 피드 캐시에 넣는다. 
	뉴스 피드 캐시는 주로 키 밸류 데이터베이스로 이루어 질 것이며, 유저의 키값에 해당 스토리를 리스트의 정렬하고, 형태로 저장한다. 
5. 만약 유저가 피드를 조회하거나 읽는다면 이를 메시지큐에 집어 넣어 유저 피드 캐시를 수정한다.

## 요약

정답은 없다. 시행착오를 거치며 최선의 구조로 나아갈 뿐이다. 

# 12장 채팅 시스템 설계

채팅 시스템은 정말 다양한 곳에서 사용되고 있다. 이를 구현해보자.

## HTTP 프로토콜을 사용해야 하는가?

HTTP는 가장 많이 사용되는 프로토콜이며 채팅 서비스와의 접속에는 HTTP 프로토콜의 keep-alive헤더를 활용하기도 한다.(TCP 핸드세이크 횟수를 줄일 수 있음) 많은 대중적인 채팅 프로그램이 전송에는 HTTP를 사용하였다.

하지만 메시지 수신 시나리오는 이것보다 복잡하다. HTTP는 클라이언트가 연결을 만드는 프토콜이며, 이를 해결하기 위해 클라이언트에서는 폴링, 롱 폴링, 웹소켓등의 기술이 생겨나게 되었다.

### 폴링

폴링은 일정시간마다 서버에게 새 메시지가 있는지 체크한다.

![](https://velog.velcdn.com/images/cksgodl/post/bab57d57-a2a2-4dae-a277-7808437acd24/image.png)

### 롱 폴링

폴링의 비효율적인 점을 개선한 폴링기법이다.

![](https://velog.velcdn.com/images/cksgodl/post/4b22e1c1-6cc8-4d70-8291-191da599cb8c/image.png)

이는 새메시지가 반환되거나 타임아웃이 될 떄까지 연결을 유지한다. 하지만 이 방법도 여러 단점이 존재한다.

- 많은 클라이언트가 서버와의 연결을 유지한다.
- 서버는 클라이언트가 연결을 해제했는지 알 방법이 없다.
- 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하지 않을 수 있다.(라운드 로빈 로드밸런서등에 따라)

### 웹 소켓

서버가 클라이언트에게 비동기메시지를 보낼 때 가장 많이 사용하는 기술이다.

![](https://velog.velcdn.com/images/cksgodl/post/ef21f97b-7f36-4314-98eb-6c8a968cce8c/image.png)

웹 소켓 연결은 클라이언트가 진행하며, 처음에는 HTTP연결을 진행하며 웹소켓 연결을 시작한다. 한번 맺어진 연결은 항구적이며 양방향이다. 

> 이는 80이나 443처럼 HTTP또는 HTTPS 프로토콜이 사용하는 기본 포트번호를 그대로 사용한다.

유의할 것은 웹소켓 연결은 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야한다는 것이다.

---

## 개략적 설계안

클라이언트와 서버 사이의 주 통신 프로토콜은 웹소켓을 사용한다. 하지만, 회원가입 로그인, 채팅방 고나리등은 웹소켓을 활용할 필요가 없다.

![](https://velog.velcdn.com/images/cksgodl/post/e9060734-bea9-422e-b395-39783e76930b/image.png)

저자는 위의 그림처럼 시스템을 설계한다.

- 채팅 서버는 클라이언트 사이의 메시지를 중계하는 역할을 한다. (웹소켓 사용)
- 접속상태 서버는 사용자의 접속 여부를 관리한다.
- API 서버는 로그인, 회원가입, 프로파일 변경 등을 관리한다.
- 알림 서버는 푸시 알림을 관리한다.
- 키-값 저장소는 채팅 이력(chat history)를 관리한다. 시스템에 접속한 사용자는 zset을 활용해 이전 채팅 이력을 모두 볼 수 있다.

---

### 키-값 저장소를 선택한 이유

본 설계안에서 키-값 저장소를 활용한 이유는 다음과 같다.

- 수령적 규모확장이 쉽다.
- 레이턴시가 같다.(O(1))
- 관계형 데이터베이스는 인덱스가 커지면 데이터에 대한 무작위 접근을 처리하는 비용이 커진다.
- 선례가 많다.(페이스북 디스코드)


### 메시지 동기화에 대하여

다양한 사용자가 거의 동시에 달느 채팅 서버에 접속하여 채팅을 하는데 어떻게 메시지가 단말간 동기화될 수 있을까?

![](https://velog.velcdn.com/images/cksgodl/post/52931543-8cd8-4c68-92f8-a02fe1ccffad/image.png)

이는 메시지 큐를 활용하여 구현된다. 각각의 사용자는 프로듀서이자, 컨슈머이며 메시지큐 스펙에 따라 동기화된다. retry, fallback 로직 등은 해당 메시지큐에서 모두 제공한다.

### 접속상태 표시

슬랙, 디스코드의 경우는 접속상태를 녹색 점으로 표현한다.

이는 웹소켓이 연결되서 `livenessprove`가 확인다면 해당 유저의 레디스에 status를 업데이트하고, 실패한다면 `livenessprove`를 업데이트하고 해당 웹소켓 연결을 끊는다. (이는 접속 장애일 때를 고려해서 구현해야 한다.)

이러한 접속상태 또한 접속상태 서비스의 메시지큐를 활용해 구현할 수 있다. `latest` 컨슈머의 형태로 메시지큐를 구독하고, 메시지 큐의 크기를 적게 유지하여 많은 사용자에게 접속 상태를 보여줄 수 있다.


![](https://velog.velcdn.com/images/cksgodl/post/ff1392d6-84b0-4937-952a-1012ae704b37/image.png)


