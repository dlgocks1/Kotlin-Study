![](https://velog.velcdn.com/images/cksgodl/post/1be3d8f4-c7ba-4886-9061-7d9d857d1bb7/image.png)

## 1.0 들어가며

`Kotlin`은 `Java` 가상 머신(JVM)을 기반으로한 최신 프로그래밍 언어이다. `Java`가 사용되는 모든 곳에서 사용할 수 있는 기능을 유지한다. `Android`는 `Kotlin`을 기본 개발 언어로 활용한다. 또한 Kotlin은 비동기 프로그래밍 을 위한 코루틴과 같은 독창적인 접근 방식을 도입했다.(코투린 이는 뒷장에서 자세히 다룬다.) 

처음엔 JVM에만 중점을 두고 시작 했지만, Kotlin은 크로스 플랫폼 솔루션을 만드는 기술을 포함하여 실행할 수 있는 더 많은 '환경'을 제공하면서 그 이상으로 크게 성장했다.(JS, Native, JVM etc..)

## 1.1 코틀린 맛보기

짧은 코틀린 코드로 특징을 짧게 설명한다.

```kotlin
data class Person( // 데이터 클래스 (toString, equals 함수 자동 오버라이딩)
	val name: String, // 읽기 전용 속성 및 생성자 필드
    val age: Int? = null // nullable 필드
)

fun main() { // 최상위 함수
    
    val persons = listof(
        Person("Alice", age = 2e), Person("Bob"),  // 후행 쉼표
     )
    val oldest = persons.maxBy { // 람다 표현식
    	it.age ?: 0 // 엘비스 연산자
    }
    println("가장 오래된 것은: $oldest") // 문자열 템플릿 
}
```

위의 예제를 직접 실행해 볼 수도 있다(https://play.kotlinlang.org/) 예제를 입력하고 실행 버튼을 클 릭하면 코드가 실행된다.

## 1.2 Kotlin의 주요 특징

`Kotlin`은 멀티 패러다임 언어이다. 이는 정적으로 유형화되어 있으므로 런타임이 아닌 컴파일 시점에 많은 오류를 발견할 수 있다. 객체 지향 언어와 함수형 언어의 아이디어를 결합하여 우아한 코드를 작성하고 강력한 추상화를 추가적으로 활용할 수 있도록 도와준다.

이후 주요 속성을 좀 더 자세히 살펴본다. 일단, __먼저 Kotlin으로 어떤 종류의 애플리케이션을 빌드할 수 있는지 살펴보겠다.__


### 1.2.1 Kotlin 사용 사례 Android, 서버 측, Java가 실행되는 모든 곳

`Kotlin`의 실행 환경은 매우 광범위하다. 또한 개발 과정에서 발생하는 모든 작업에 대해 전반적인 생산성 향상을 제공하며 뛰어난 가독성, 특정 도메인 이나 프로그래밍 패러다임을 지원하는 라이브러리와의 뛰어난 수준의 통합을 목표로 한다. (자바 라이브러리는 모두 사용할 수 있다.)

일반적인 Kotlin 사용 사례는 다음과 같다.
- Android 기기에서 실행되는 모바일 애플리케이션 구축
- 서버 측 코드 빌드(일반적으로 웹 애플리케이션의 백엔드)

`Kotlin`의 초기 목표는 `Java`를 사용할 수 있는 모든 환경에서도 보다 적합하고 간결하고 생산적이며 안전한 `Java` 네이티브 대체 도구를 제공하는 것이다. 여기에는 소규모 디바이스 실행부터 대규모 데이터 센터에 이르기까지 다양한 환경이 포함된다. 이러한 모든 사용 사례에서 `Kotlin`은 완벽하게 적합하며 개발자는 더 적은 코드와 번거로움 없이 작업을 수행할 수 있다.

하지만 `Kotlin`은 다른 환경에서도 작동한다. `Kotlin` 멀티플랫폼을 사용하면 `데스크톱`, `iOS` 및 `Android`용 크로스 플랫폼 애플리케이션을 만들 수 있으며 브라우저에서 `Kotlin`을 실행할 수도 있다. 

이 책은 주로 언어 자체와 `JVM` 대상의 복잡한 기능에 초점을 맞추고 있다. 이외의 `Kotlin` 애플리케이션에 대한 광범위한 정보는 Kotlin 웹 사이트(https://kotl.in/)에서 확인할 수 있다.

### 1.2.2 정적 타이핑을 통한 성능, 안정성 및 유지 관리가 용이한 Kotlin

정적으로 타입이 지정된 프로그래밍 언어에는 성능, 안정성, 유지보수성, 도구 지원 등 여러 가지 장점이 있다. 정적 언어의 주요 장점은 프로그램의 모든 표현식의 에러 및 워닝을 컴파일 시점에 알 수 있다는 것이다. 

Kotlin은 정적으로 `타입`이 지정된 프로그래밍언어로, `Kotlin`컴파일러는 객체에서 액세스하려는 메서드와 필드가 실제로 존재하는지 확인할 수 있다. 따라서 필드가 누락되거나 함수 호출의 반환 유형이 예상과 다른 경우 런타임에 충돌이 발생하는 대신 컴파일 시 이러한 문제를 확인할 수 있으므로 개발 주기 초기에 문제를 해결할 수 있어 전체 클래스의 버그를 제거하는 데 도움이 된다.

> 위의 정적 언어 설명은 `코틀린` 뿐만 아니라 `자바`에도 해당 되는 이야기이다. 정적 프로그래밍이라는 단어가 어렵다면 단순하게 타입이 지정되어있는 프로그래밍 언어라고 생각하여도 좋다. (java, typescript, kotlin...)

다음은 정적 타이핑의 몇 가지 장점을 나타낸다.

- 성능 - 런타임에 어떤 메서드를 호출해야 하는지 결정할 필요가 없으므로 메서드 호출이 더 빨라진다.
- 신뢰성 - 컴파일러는 유형을 사용하여 프로그램의 일관성을 확인하므로 런타임에 충돌이 발생할 가능성이 적다.
- 유지보수성 - 코드가 어떤 유형으로 작동하는지 확인할 수 있으므로 작업하는 것이 더 쉽다.
- 도구지원 - 정적타이핑을 통해 안정적인 리팩터링, 정확한 코드완성 및 기타 IDE 기능을 사용할 수 있다.

정적 언어의 경우 컴파일 시점에 프로그램의 모든 표현식의 유형을 알아야 하지만 `Kotlin`에서는 소스 코드에서 모든 변수의 유형을 명시적으로 지정할 필요가 없다. 왜냐하면 대부분의 경우 컨텍스트에서 변수 유형을 자동으로 결정할 수 있기 때문이다. 즉 따라서 타입 선언을 생략할 수 있다. 

```kotlin
val x: Int = 1
val y = 1 // 타입 선언 생략
```

변수를 선언하는 중 정수값으로 초기화되었으므로 `Kotlin`은 자동으로 해당 변수의 유형이 `Int`라고 판단한다. 컴파일러가 컨텍스트에서 유형을 결정하는 기능을 `타입 추론`이라고 한다. `Kotlin`에서 타입 추론을 사용하면 유형을 명시적으로 선언할 필요가 없으므로 정적 유형 지정과 관련된 대부분의 추가 복잡성이 사라지고, 가독성이 증가한다.

> 코틀린에서 이런 타입추론은 `스마트 캐스트`라고 불리운다.

`Kotlin`의 유형 시스템의 세부 사항을 살펴보면 다른 객체 지향 프로그래밍 언어와 유사한 개념을 많이 찾을 수 있다.(특히 자바) 예를 들어 클래스와 인터페이스는 예상하는 대로 작동한다. 또한 `Java` 개발자라면 제네릭과 같은 지식이 `Kotlin`에서 동일하게 적용된다.

한 가지 중요한 점은 런타임에 충돌이 발생하는 대신 컴파일 시 발생할 수 있는 널 포인터 예외를 감지하여 보다 안정적인 프로그램을 작성할 수 있도록 하는 `Kotlin`의 `nullable` 유형 지원이다.

> 코틀린은 기본적으로 `null`을 허용하지 않으며 null을 허용하고자 한다면 타입 선언 뒤에 `?`를 붙여 선언한다.
```kotlin
val nullableInt: Int? = 5
```

`Kotlin`의 유형 시스템은 함수형(람다)에 대해서도 최고 수준의 지원을 제공한다. 이에 대해 아래에서 알아본다.

### 1.2.3 함수형 프로그래밍과 객체 지향 프로그래밍을 결합하여 안전하고 유연하 게 만드는 Kotlin

`Kotlin`은 객체 지향 접근 방식과 함수형 프로그래밍 스타일을 결합한다. 함수형 프로그래밍의 주요 개념은 다음과 같다.

- 일급 함수 - 함수를 값으로 사용하여 작업한다. 변수에 저장하거나 매 개변수로 전달하거나 다른 함수에서 반환할 수 있다.
- 불변성 - 생성 후 상태가 변경되지 않도록 보장하는 불변 객체로 작업한다.
- 부작용없음 - 동일한 입력이 주어지면 동일한 결과를 반환하는 순수 함수,즉 다른 객체의 상태를 수정하거나 외부 세계와 상호 작용하지 않는 함수를 작성한다.

함수형 스타일로 코드를 작성하면 어떤 이점을 얻을 수 있을까? 

첫째, 간결성이라는 이점이 있다. 함수형 코드는 명령형 코드와 비교할 때 더 우아하고 간결할 수 있다. 변수를 변경하고 루프와 조건부 분기에 의존하는 대신 함수를 값으로 사 용하면 훨씬 더 강력한 추상화 능력을 발휘할 수 있다.

둘째, 안전한 동시성이다. 멀티스레드 프로그램에서 오류의 가장 큰 원인 중 하나는 적절한 동기화 없이 여러 `'액터'(여러 스레드)`에서 동일한 데이터를 수정하는 것이다. 변경 불가능한 데이터 구조와 순수 함수를 사용하면 이러한 안전하지 않은 수정이 발생하지 않도록 할 수 있으며 복잡한 동기화 체계를 만들 필요가 없다.

마지막으로, 함수형 프로그래밍은 테스트가 더 쉽다. 부작용이 없는 함수는 의존하는 전체 환경을 구성하기 위해 많은 설정 코드를 작성할 필요 없이 개 별적으로 테스트할 수 있다.

많은 언어는 함수형 프로그래밍을 쉽게 사용하는 데 필요한 구문 및 라이브러리 지원을 제공하지 않는다. `Kotlin`은 처음부터 함수형 프로그래밍을 지원하는 풍부한 기능을 제공한다.

- `함수 유형` - 함수가 다른 함수를 인수로 받거나 다른 함수를 반환할수있도록 허용한다.
- `람다 표현식` - 코드 블록을 최소한의 빌링으로 전달할 수 있다.
- `멤버 참조` - 함수를 값으로 사용할 수 있으며, 인자로도 전달할 수 있다.
- `데이터 클래스` - 불변데이터를 저장할 수 있는 클래스를 만들기 위한 간결한클래스를 제공한다.
- `표준 라이브러리API` - 함수형스타일의 객체 및 컬렉션 작업을 위한 표준라이브 러리의 풍부한 세트를 제공한다.

아래 예제는 주어진 메시지 시퀀스가 "비어 있지 않은 읽지 않은 메시지의 모든 고유 발신자를 이름별로 정렬"하여 찾는 에제이다.

```kotlin
message.filter { it.body.isNotBlank() && !it.isRead }
	.map(메시지::발신자)
    .distinct()
	.sortedBy(발신자::이름)
```

`Kotlin` 표준 라이브러리에는 사용자가 사용할 수 있는 `filter`, `map` 및 `sortedBy`와 같은 함수가 정의되어 있다. `Kotlin` 언어는 람다 표현식 및 멤버 참조(예: `Message::sender`)를 지원하므로 이러한 함수에 전달되는 인수가 매우 간결하다.

> 멤버 참조에 대해서는 이후에 나올 코틀린 레플렉션(reflection)장을 참고하라.

> Kotlin Collection API는 정말 다양한 기능을 제공한다. 아래는 filter로 시작하는 collection API의 예제이다.
![](https://velog.velcdn.com/images/cksgodl/post/7e8945ed-75e5-4442-906c-d8fa490707f7/image.png)

`Kotlin`에서 코드를 작성할 때는 `객체 지향 접근 방식`과 `함수형 접근 방식`을 모두 결합하여 해결하려는 문제에 가장 적합한 방법을 제공한다. 필요할 때 별도의 단계를 거치지 않고도 함수형 프로그래밍의 모든 기능을 활용할 수 있고, 변경 가능한 데이터로 작업하고 부작용이 있는 함수를 작성할 수도 있다. 물론 인터페이스 및 클래스 계층 구조에 기반한 프레임워크로 작업하는 것도 쉽다.

### 1.2.4 코루틴을 사용하면 동시 및 비동기 코드가 자연스럽고 구조화된다.

서버, 데스크톱 또는 모바일에서 실행되는 애플리케이션을 구축할 때 여러 코드를 동시에 실행하는 동시성은 거의 피할 수 없는 주제이다. 서버측 애플리케이션도 단일 요청이 평소보다 훨씬 오래 걸리는 경우에도 들어오는 요청을 계속 처리해야 한다. 

`스레드, 콜백, 퓨처, 프로미스, 리액티브 확장` 등 동시성에 대한 많은 접근 방식이 존재해 왔다. `Kotlin`은 코루틴이라는 일시 중단 가능한 계산을 사용하여 동시 및 비동기 프로그래밍 문제에 접근하며, 코드가 실행을 일시 중단했다가 나중에 작업을 다시 시작할 수 있다.

아래 예제에서는 다음과 같이 세 번의 네트워크 호출을 수행하는 `processUser` 함수를 정의 한다.

```kotlin
suspend fun processUser(credentials: Credentials) {
    val user = authenticate(credentials)
    val data = loadUserData(user)
    val profilePicture = loadImage(data.imageID) // 쓰레드 차단 없이 비동기로 실행됩니다.
	// ...
}

suspend fun authenticate(c: Credentials): User { /* ... */ }
suspend fun loadUserData(u: User): Data { /* ... */ }
suspend fun loadImage(id: Int): Image { /* ... */ }
```

네트워크 호출은 임의로 오래 걸릴 수 있다. 각 네트워크 요청을 수행할 때 결과를 기다리는 동안 `processUser` 함수의 실행이 일시 중단된다. 하지만 이 코드가 실행 중인 스레드(그리고 더 나아가 애플리케이션 자체)는 차단되지 않으며, 프로세스유저의 결과를 기다리는 동안 사용자 입력에 응답하는 등 다른 작업을 수행할 수 있다.

이 코드를 명령형 방식으로 순차적으로 작성하려면 기본 스레드를 차단하지 않고는 한 호출씩 순차적으로 작성할 수 없다. 반면에 콜백이나 반응형 스트림을 사용하면 이러한 단순한 연속 로직은 훨씬 더 복잡해진다.

다음 예제에서는 비동기를 사용하여 두 개의 이미지를 동시에 로드한 다음 `await`을 통해 로드가 완료될 때까지 기다렸다가 이미지의 합쳐 반환하는 예제이다.

```kotlin
suspend fun loadAndOverlay(first: String, second: String): Image =
    coroutineScope {
    val firstDeferred = async { loadImage(first) }
    val secondDeferred = async { loadImage(second) }
    combineImages(firstDeferred.await(), secondDeferred.await())
}
```

코루틴은 또한 매우 가벼운 추상화이므로 성능에 큰 영향을 주지 않고도 수많은 동시 작업을 실행할 수 있다. 

(이 책의 3부 전체는 코루틴에 대해 자세히 알아보고 사용 사례에 코루틴을 가장 잘 적용할 수 있는 방법을 이해하는 데 전념한다.)


### 1.2.5 무료 오픈 소스이기에 Kotlin은 어떤 용도로든 사용할 수 있다.

컴파일러, 라이브러리 및 모든 관련 툴을 포함한 Kotlin 언어는 완전히 오픈 소스 이며 어떤 용도로든 무료로 사용할 수 있다. `Apache 2` 라이선스에 따라 사용 가능하며, 개발은 GitHub(http://github.com/jetbrains/ kotlin)에서 공개적으로 이루어진다. 

## 1.3 Kotlin이 자주 사용되는 분야

### 1.3.1 백엔드 지원 Kotlin을 사용한 서버 측 개발

백엔드 서버의 역할은 광범위하며 아래 같은 유형이 포함된다.
- HTML 페이지를 브라우저에 반환하는 웹 애플리케이션
- HTTP를 통해 JSON API를 노출하는 모바일 또는 단일 페이지 애플리케이션용 백엔드
- RPC 프로토콜 또는 메시지 버스를 통해 다른 마이크로서비스와 통신하는 마이크로 서비스

개발자들은 수년 동안 `JVM`에서 이러한 종류의 애플리케이션을 구축해 왔으며, 이를 구축하는 데 도움이 되는 방대한 프레임워크와 기술 스택을 축적해 왔다. 이러한 애플리케이션은 일반적으로 단독으로 개발되거나 처음부터 시작되지 않는다. 확장, 개선 또는 교체되는 기존 시스템이 거의 항상 존재하며, 새로운 코드는 수 년 전에 작성되었을 수 있는 시스템의 기존 부분과 통합되어야 한다.

__특히 이러한 환경에서 `Kotlin`은 기존 `Java` 코드와의 원활한 상호 운용성을 통해 이점을 얻는다.__ 새 컴포넌트를 작성하든 기존 서비스의 코드를 `Kotlin`으로 마이그레이션하든 관계없이 `Kotlin`은 바로 사용할 수 있다. `Kotlin`에서 `Java` 클래스를 확장하거나 특정 방식으로 클래스의 메서드와 필드에 주석을 달아야 할 때 문제가 발생하지 않다. 문제보단 오히려 시스템의 코드가 더 간결하고 안정적이며 유지 관리가 더 쉬워진다는 이점이 있다.

`Kotlin` 사용의 또 다른 큰 장점은 애플리케이션의 안정성이 향상된다는 점이다. 널 값을 정밀하게 추적하는 `Kotlin`의 유형 시스템은 널 포인터예외 문제를 훨씬 덜 심각하게 만든다. `Java`에서 런타임에 널 포인터 예외를 발생시키는 대부분의 코드는 `Kotlin`에서 컴파일되지 않으므로 애플리케이션이 프로덕션 환경에 도달하기 전에 오류를 수정할 수 있다.

`Spring`(https://spring.io/)과 같은 최신 프레임워크는 `Kotlin`을 위한 최고 수준의 지원을 제공한다. 이러한 프레임워크는 원활한 상호 운용성 외에도 추가 확장 기능을 포함하며 처음부터 `Kotlin`을 위해 설계된 것처럼 느껴지는 기술을 제공한다.

아래 예제에서는 ID와 일부 텍스트로 구성된 `Greeting` 객체 목록을 `HTTP`를 통해 `JSON`으로 제공하는 간단한 `Spring Boot` 애플리케이션이다. `Spring` 프레임워크의 개념은 아래 표시된 것처럼 `Java`를 사용할 때와 동일 한 어노테이션(`@SpringBootApplication`, `@RestController`, `@GetMapping`)을 사용하여 `Kotlin`으로 직접 전달되어 사용될 수 있다.

```kotlin
@SpringBootApplication
class DemoApplication

fun main(args: Array<String>) {
    runApplication<DemoApplication>(*args)
}

@RestController
class GreetingResource {
    @GetMapping
    fun index(): List<Greeting> = listOf(
        Greeting(1, "Hello!"),
        Greeting(2, "Bonjour!"),
        Greeting(3, "Guten Tag!"),
) }
```

![](https://velog.velcdn.com/images/cksgodl/post/b5ccc64f-88f9-4128-a180-30514aa89811/image.png)

또한 `Kotlin`은 서버 측 프레임워크를 비롯한 자체 라이브러리 에코시스템이 계속 성장 하고 있다. 예를 들어, `Ktor`(https://ktor.io/)는 `JetBrains`에서 구축한 `Kotlin`용 애플리케이션 프레임워크로, 서버 측 애플리케이션을 빌드하고 클라이언트 및 모바일 애플리케이션에서 네트워크 요청을 하는 데 사용할 수 있다. 

`Kotlin` 프레임워크인 `Ktor`는 언어의 기능을 최대한 활용한다. 어노테이션이나 XML 파일을 사용하여 애플리케이션을 구성하는 대신 `Ktor`의 `DSL`을 사용하여 아래와 같은 예제처럼 서버 측 애플리케이션의 라우팅을 구성할 수 있다.

```kotlin
fun main() {
    embeddedServer(Netty, port = 8000) {
        routing {
            get ("/world") {
                call.respondText("Hello, world!")
            }
            route("/greet") {
                get { /* . . . */ }
                post("/{entityId}") { /* . . . */ }
} }
    }.start(wait = true)
}
```

`DSL`은 `Kotlin` 언어 기능을 유연하게 결합하며 구성, 복잡한 객체 구성 또는 객체를 데이터베이스 표현으로 변환하거나 그 반대로 변환하는 객체 관계형 매핑(ORM) 작업에 자주 사용된다.

`http4k`(https://http4k.org/)와 같은 다른 `Kotlin` 서버 측 프레임워크는 `Kotlin` 코드의 기능적 특성을 강력하게 수용하며 요청 및 응답에 대한 간단하고 통일된 추상화를 제공한다. 

### 1.3.2 모바일 개발: 안드로이드는 코틀린이 우선입니다, 멀티플랫폼: iOS, JVM, JS 

전 세계에서 가장 많이 사용되는 모바일 운영 체제인 Android는 2017년에 앱 빌드용 언어로 Kotlin을 공식적으로 지원하기 시작했으며, 불과 2년 후인 2019년에 개발 자들의 많은 긍정적인 피드백을 바탕으로 Android가 가장 먼저 Kotlin을 지원하여 기본 언어가 되었다.

_이후 내용은 모바일 개발자, 프론트 개발자라면 직접 사서 읽어보는 것을 권장한다._

## 1.4 Kotlin의 철학

`Kotlin`에 대해 이야기할 때 자바와의 상호 운용성에 중점을 둔 실용적이고 간결하며 안전한 언어라는 표현을 자주 사용한다. 이러한 각 단어는 정확히 무엇을 의미하는지 차례로 살펴본다.

### 1.4.1 Kotlin은 실용적이다.

`Kotlin`은 실제 문제를 해결하기 위해 설계된 실용적인 언어이다. 다년간의 대규모 시스템 개발 업계 경험을 바탕으로 설계 되었으며, 많은 소프트웨어 개발자가 직면하는 사용 사례를 해결하기 위해 기능이 선택 되었다. 또한 전 세계 개발자들은 약 10년 동안 `Kotlin`을 사용해 왔다. 이들의 지속적인 피드백을 통해 언어의 각 버전이 출시될 때마다 발전해 왔으며, 이를 통해 `Kotlin`이 실제 프로젝트에서 문제를 해결하는 데 도움이 된다고 자신 있게 말할 수 있다.

_등등.. 코틀린에 대한 자랑이 이어진다._

Kotlin은 특정 프로그래밍 스타일이나 패러다임 사용을 강요하지 않는다. 언어를 공부하기 시작하면 자신에게 익숙한 스타일과 기술을 사용할 수 있다. 
- 확장 함수(3.3장)
- 표현식 유형 시스템(7장 및 8장)
- 고차 함수(10장) 

`Kotlin`의 실용주의의 또 다른 측면은 툴링에 중점을 둔다는 점이다. 스마트한 개발 환경은 좋은 언어만큼이나 개발자의 생산성을 위해 필수적이며, 그렇기 때문에 `IDE` 지원 을 나중에 고려하는 것은 선택 사항이 아니다. `Kotlin`의 경우 `IntelliJ IDEA` 플러그인 은 컴파일러와 함께 개발되며, 랜더링 기능은 항상 툴링을 염두에 두고 설계된다.

### 1.4.2 Kotlin은 간결하다.

개발자가 새로운 코드를 작성하는 것보다 기존 코드를 읽는 데 더 많은 시간을 소비한다는 것은 기본 상식이다. 대규모 프로젝트를 개발하는 팀의 일원으로 새로운 기능을 추가하거나 버그를 수정해야 한다고 상상해보자. 가장 먼저 무엇을 할까? 변경해야 할 코드의 정확한 부분을 찾은 다음 수정 사항을 구현한다. 해야 할 일을 찾기 위해 많은 코드를 읽는다. 이 코드는 동료나 더 이상 프로젝트에서 일하지 않는 사람이 최근에 작성했을 수도 있고, 오래 전에 본인이 작성했을 수도 있다. 주변 코드를 이해한후에야 필요한 수정을 할 수 있다.

코드가 간단하고 간결할수록 무슨 일이 일어나고 있는지 더 빨리 이해할 수 있다. 물론 여기에는 좋은 구조 및 컨벤션이 중요한 역할을 하며, 변수, 함수, 클래스가 이름에 정확하게 설명되도록 표현력 있는 이름을 선택하는 것도 중요하다. 하지만 __언어의 선택__과 __간결함__도 중요하다다. 

`Kotlin`은 사용자가 작성하는 모든 코드가 의미를 전달하고 단순히 코드 구조 요구 사항을 충족하기 위해 존재하는 것이 아니고, 가성비를 중요시 한다. 게터, 세터, 필드에 공용 구조체 매개 변수를 할당하는 로직 등 객체 지향 언어의 표준 상용구는 대부분 `Kotlin`에 암시되어 있으므로 소스 코드를 복잡하게 만들지 않는다. 세미콜론도 `Kotlin`에서 생략할 수 있으므로 코드에서 약간의 추가 복잡성을 제거할 수 있으며, 강력한 유형 추론 기능을 통해 컴파일러가 컨텍스트에서 유형을 추론할 수 있는 유형을 명시적으로 지정하지 않아도 된다.

`Kotlin`에는 이러한 길고 반복적인 코드 섹션을 라이브러리 메서드 호출로 대체할 수 있는 풍부한 표준 라이브러리가 있다. `Kotlin`은 람다 및 익명 함수(표현식처럼 사용되는 함수 리터럴)를 지원하므로 작은 코드 블록을 라이브러리 함수에 쉽게 전달할 수 있다. 이를 통해 라이브러리에서 모든 공통 부분을 캡슐화하고 사용자 코드에는 고유한 작업별 부분만 유지할 수 있다.

동시에 `Kotlin`은 소스 코드를 가능한 한 가장 적은 수의 문자로 축소하려고 하지 않는다. 예를 들어 `Kotlin`은 고정된 연산자 집합의 오버로드를 지원하므로 `+, -, in` 또는 `[]`에 대한 사용자 지정 구현을 제공할 수 있다. 하지만 사용자가 직접 사용자 지정 연산자를 정의할 수는 없다. 따라서 개발자는 메서드 이름을 암호화하거나, 구두점 시퀀스로 대체할 수 없다. (이런 행동은 명시적 이름을 사용하는 것보다 읽기 어렵고 문서 시스템에서 찾기 어렵게 한다.)

간결한 코드는 작성하는 데 시간이 덜 걸리고, 더 중요한 것은 읽고 이해하는 데 시간 이 덜 걸린다는 것이다. 따라서 생산성이 향상되고 작업을 더 빠르게 완료할 수 있다.

### 1.4.3 Kotlin은 안전하다.

물론 모든 오류를 방지하는 언어는 없다. 또한 오류를 방지하려면 일반적으로 비용이 발생한다. 컴파일러에 프로그램의 의도된 동작에 대한 더 많은 정보를 제공해야 컴파일러가 그 정보가 프로그램이 수행하는 작업과 일치하는지 확인할 수 있다. 따라서 안전성을 높이는 수준과 더 자세한 주석을 넣는 데 필요한 생산성 손실 사이에는 항상 상충 관계가 있다.

`JVM`에서 어플리케이션을 실행하면 메모리 안전, 버퍼 오버플로 방지, 기타 잘못된 동작을 방지하기 위해 동적으로 할당된 메모리를 사용한다. 또한 `JVM`에서 정적으로 입력되는 언어인 `Kotlin`은 애플리케이션의 유형 안전성을 보장한다. 또한 `Kotlin`은 읽기 전용 변수를 쉽게 정의하고(`val` 키워드를 통해) 불변(데이터) 클래스로 빠르게 그룹화할 수 있어 멀티스레드 애플리케이션에 추가적인 안전성을 제공한다.

그 외에도 `Kotlin`은 컴파일 시간 동안 검사를 수행하여 런타임에 발생하는 오류를 방지하는 것을 목표로 한다. 가장 중요한 것은 `Kotlin`이 프로그램에서 `NullPointer` 예외를 제거하기 위해 노력한다는 것이다. `Kotlin`의 유형 시스템은 널이 될 수 있는 값과 될 수 없는 값을 추적하고 런타임에 널포인터 예외를 유발할 수 있는 연산을 금지한다. (이를위해 필요한 추가 비용은 최소화된다.) 유형을 `null` 가능으로 표시하는 데는 끝에 물음표인 `?`글자만 있으면 된다.

```kotlin
fun main() {
	var s: String? = null 
    var s2: String = ""
	println(s.length) 
    println(s2.length)
}
```

이를 보완하기 위해 `Kotlin`은 `null` 가능한 데이터를 처리하는 여러 가지 편리한 방법 을 제공한다.

`Kotlin`이 방지하는 또 다른 유형의 예외는 클래스 형변환 예외로, 올바른 형인지 먼저 확인하지 않고 객체를 형으로 형 변환할 때 발생하는 예외이다. `Kotlin`은 확인과 형 변환을 단일 작업으로 결합한다. 즉, 유형을 확인한 후에는 추가 형 변환, 재선언 또는 검사 없이 해당 유형의 멤버를 참조할 수 있다.


```kotlin
fun modify(value: Any) {
    if (value is String) {
        println(value.uppercase())
    }
}
```

위 예제에서 `is`는 `Any` 타입일 수 있는 값 변수에 대해 타입 검사를 수행한다. 컴파일러는 조건의 실제 분기에서 값의 타입이 `String`이어야 한다는 것을 알고 있으므로 해당 타입의 메서드 사용을 안전하게 허용한다.(String의 uppercase()를 사용 가능)

### 1.4.4 상호 운용이 가능한 Kotlin

상호 운용성과 관련하여 가장 먼저 걱정되는 것은 "기존 라이브러리를 사용할 수 있나요?" 일 것이다. `Kotlin`을 사용하면 `"네, 물론입니다."`라는 대답이 돌아온다. `API`의 종류에 관계없이 라이브러리가 필요한 경우 `Kotlin`에서 해당 라이브러리로 작업할 수 있다.

`Java` 메서드를 호출하고, `Java` 클래스를 확장하고 인터페이스를 구현하고, `Kotlin` 클래스에 `Java` 어노테이션을 적용하는 등의 작업을 무리없이 수행할 수 있다.

다른 `JVM` 언어와 달리 `Kotlin`은 상호 운용성을 더욱 강화하여 `Java`에서도 `Kotlin` 코드를 쉽게 호출할 수 있다. `Kotlin` 클래스와 메서드는 일반 `Java` 클래스 및 메서드와 똑같이 호출할 수 있다. 따라서 프로젝트의 어느 곳에서나 `Java`와 `Kotlin` 코드를 혼합할 수 있는 최고의 유연성을 제공한다. `Java` 프로젝트에 `Kotlin` 을 도입하기 시작하면 코드베이스의 단일 클래스에서 `Java-to-Kotlin` 변환기를 실행 하면 나머지 코드는 아무런 수정 없이 계속 컴파일되고 작동한다. 

`Kotlin`이 상호 운용성에 중점을 두는 또 다른 영역은 기존 `Java` 라이브러리를 최대한 활용한다는 점이다. 예를 들어, `Kotlin`의 컬렉션은 거의 전적으로 `Java` 표준 라이브러리 클래스에 의존하며, `Kotlin`에서 더 편리하게 사용할 수 있도록 추가 함수로 확장한다. 

즉, `Kotlin`에서 `Java API`를 호출할 때 객체를 래핑하거나 변환할 필요가 없으며, 그 반대의 경우도 마찬가지이다. `Kotlin`에서 제공하는 모든 풍부한 `API`는 런타임에 제공된다.

### 1.5.3 Kotlin 코드 컴파일

`Kotlin`을 실행하고자 한다면 먼저 컴파일 해야한다. (코틀린은 다양한 타겟에 컴파일 될 수 있다.)

예시 타겟을 다음과 같다.

- JVM에서 실행할 JVM 바이트코드(.class 파일에 저장됨)
- JVM 바이트코드를 추가로 변환하여 Android에서 실행할 수 있다.
- 다양한 운영 체제에서 기본적으로 실행되는 네이티브 타겟 
- 브라우저에서 실행할 JavaScript(및 WebAssembly)

> `Kotlin` 컴파일러의 경우 생성된 `JVM` 바이트코드가 `JVM`에서 실행되는지 아니면 추가로 변환되어 `Android`에서 실행되는지는 중요하지 않다. `Android` 런타임 (`ART`)은 `JVM` 바이트코드를 `Dex` 바이트코드로 변환하여 대신 실행한다.

`Kotlin` 소스 코드는 일반적으로 확장자가 `.kt`인 파일에 저장된다. 컴파일러는 `JVM` 대상에 대한 `Kotlin` 코드를 컴파일할 때 소스 코드를 분석하여 `.class` 파일을 생성한다. 그런 다음 생성된 `.class` 파일은 작업 중인 애플리케이션 유형에 대한 표준 절차에 따라 팩 에이징되고 실행된다.

가장 간단한 경우, 명령줄에서 코드를 컴파일할 때는 `kotlinc` 명령을 사용하고 코드를 실행할 때는 java 명령을 사용하면 된다.

```
kotlinc <소스 파일 또는 디렉터리> -include-runtime -d <jar 이름> 자바 - jar <jar 이름>
```

JVM은 Kotlin 코드에서 컴파일된 `.class` 파일을 처음에 `Java`로 작성되었는지 또는 `Kotlin`으로 작성되었는지 알지 못해도 실행할 수 있다. 그러나 `Kotlin`에 내장된 클래스와 해당 `API`는 `Java`의 클래스와 다르며, 컴파일된 코드를 올바르게 실행하려면 `JVM`에 종속성으로 추가 정보인 `Kotlin` 런타임 라이브러리가 필요하다.

대부분의 실제 사례에서 코드를 컴파일할 때 `Gradle` 또는 `Maven`과 같은 빌드 시스템을 사용하게 된다. `Kotlin`은 이러한 빌드 시스템과 호환된다. 이러한 모든 빌드 시스템은 `Kotlin`과 `Java`를 결합하는 혼합 언어 프로젝트도 지원한다.

![](https://velog.velcdn.com/images/cksgodl/post/15780a3e-c18e-410f-8ca1-e9381d64bf51/image.png)

자세한 내용을 확인 하는 가장 좋은 최신 방법은 `Kotlin` 설명서(https://kotlinlang.org/docs/gradle.html 및 https://kotlinlang.org/docs/maven.html) 을 살펴보는 것이다.

## 요약

- `Kotlin`은 정적으로 유형화되고 유형 추론을 지원하므로 소스 코드를 간결하게 유지하면서 정확성과 성능을 유지할 수 있다.
- `Kotlin`은 객체 지향 및 함수형 프로그래밍 스타일을 모두 지원하므로 일급 함수를 통해 더 높은 수준의 추상화가 가능하고 불변 값을 지원하여 테스트 및 멀티스레드 개발을 간소화할 수 있다.
- 코루틴은 스레드의 가벼운 대안으로, 순차 코드와 유사한 로직을 작성하고 부모 자식 관계에서 동시 코드를 구조화하여 비동기 코드가 자연스럽게 느껴지도록 도와준다.
- `Kotlin`은 `Ktor` 및 `http4k`와 같은 `Kotlin` 우선 프레임워크를 사용하는 서버 측 애플 리케이션에 적합할 뿐만 아니라 `Spring Boot`와 같은 기존의 모든 `Java` 프레임워크를 완벽하게 지원한다.
- 개발 도구, 라이브러리, 샘플 및 설명서가 모두 `Kotlin`에 중점을 두고 있으며, `Android`는 `Kotlin`이 우선이다.
- `Kotlin`은 무료 오픈 소스이며 여러 빌드 시스템 및 IDE를 지원
