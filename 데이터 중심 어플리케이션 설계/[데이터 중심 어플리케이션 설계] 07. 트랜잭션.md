_냉혹한 서버의 세계에서 대부분의 장애는 데이터베이스에 발생한다._

신뢰성 있는 DB를 구현하기 위해 트랜잭션이 필요하다.

> 트랜잭션은 읽기와 쓰기를 하나의 논리적 단위로 묶고, 실패하면 커밋, 실패하면 롤백하는 개념을 의미한다.

## 애매모호한 트랜잭션의 개념

현대의 거의 모든 관계형 데이터베이스와 일부 비관계형 데이터베이스는 트랜잭션을 지원한다. 하지만 이런 트랜잭션은 트레이드오프가 확실하다.

### ACID의 의미

트랜잭션이 제공하는 안전선 보장은 **ACID**로 잘 알려져 있다.

> - 원자성 : `Atomicity`
- 일관성 : `Consistency`
- 격리성 : `Isolation`
- 지속성 : `Durability`

현실에서의 `ACID`개념 구현은 제각각이다. 상위 수준의 아이디어는 견고하지만 세부 사항은 모호함이 많이 있다. _ACID는 거의 데이터베이스 회사의 마케팅 용어로 사용되고 있다._

각각의 개념에 대해 자세히 알아보자.

### 원자성 : Atomicity

__원자성은 트랜잭션이 모두 성공하거나 전혀 실행되지 않는 것을 보장하는 속성이다.__

```
1) 상황:
계좌 A에서 계좌 B로 100원을 송금하는 트랜잭션.

1. 계좌 A에서 100원 출금.
2. 계좌 B에 100원 입금.

원자성 보장을 위해

- 트랜잭션 중간에 시스템 장애가 발생하면, 출금만 되고 입금이 되지 않는 상황을 방지.
- 트랜잭션이 성공적으로 완료되면 계좌 A와 계좌 B의 상태가 모두 반영.
- 실패 시, 계좌 A의 금액은 원래 상태로 복구되고 계좌 B는 변하지 않음.
```

```
2) 상황
사용자가 제품을 구매하면 다음 작업이 수행되는 트랜잭션.

1. 재고 감소.
2. 결제 처리.
3. 주문 기록 저장.

원자성 보장을 위해

- 트랜잭션 도중 결제가 실패하면, 재고 감소와 주문 기록 저장이 롤백됨.
- 모든 작업이 성공해야만 트랜잭션이 완료되고, 데이터베이스가 갱신됨.
- 실패 시, 재고는 감소하지 않고 주문 기록도 저장되지 않음.
```

원자적의 뜻은 더 쪼갤 수 없는 뭔가를 가리킨다. _(실제로는 원자말고 분자, 쿼크 등 더 작은 단위가 많다.)_ 예를 들어 클라이언트가 쓰기 작업 몇 개를 실행하려고 하는데, 그 중 일부만 처리된 후 결함이 생기면 모든 작업을 실패(어보트)한다. __여러 쓰기 작업을 하나의 원자적 단위__로 묶기 때문이다.

원자성 없이는 어떤 작업을 성공했고, 어떤 작업은 실패했는지 알기 어렵다. 트랜잭션은 이를 단순하게 만들어준다. 트랜잭션에서 실패시 모든 것을 롤백하는 능력은 원자성의 결정적인 특징이다. 저자는 __어보트 능력(`abortability`)__이 __원자성__보다 더 나은 단어라고 표현한다.

### 일관성 : Consistency

__트랜잭션 전후에 데이터베이스의 무결성과 일관성이 보장되는 상태를 의미한다.__

데이터베이스는 트랜잭션이 시작되기 전과 완료된 후에 일관된 상태를 유지해야 한다. 예를들어 다음과 같다.

```
1) 은행 송금
계좌 A에서 계좌 B로 100원을 송금하는 트랜잭션:

1. 계좌 A에서 100원을 출금.
2. 계좌 B에 100원을 입금.
3. 트랜잭션 완료 후, 데이터베이스의 총 금액은 변하지 않음.
-> 일관성 유지

출금과 입금이 동시에 이루어져야 함.
트랜잭션 중 오류 발생 시, 데이터베이스는 원래 상태로 복구.
```

```
2) 주문 처리 시스템
제품 주문 트랜잭션:

1. 재고를 확인.
2. 주문을 생성.
3. 재고 수량을 감소.
-> 일관성 유지

재고가 부족하면 주문이 생성되지 않아야 함.
트랜잭션 도중 오류가 발생하면, 재고 상태가 변경되지 않아야 함.
```

> 일관성의 아이디어는 애플리케이션에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 __애플리케이션의 책임이다.__

이는 DB가 보장할 수 있는게 아니다. DB는 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다.  원자성, 격리성, 지속성은 DB의 속성인 반면 (ACID에서의) 일관성은 애플리케이션의 속성이다. 

애플리케이션에서 일관성을 달성하기 위해 DB의 원자성과 격리성 속성에 기댈 수는 있지만 DB만으로 되는 것은 아니다 따라서 C는 실제로는 ACID에 속하지 않는다.

### 격리성 Isolation

__격리성은 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션이 서로 간섭하지 않고 독립적으로 실행되도록 보장하는 데이터베이스의 속성이다.__

이는 데이터의 무결성을 유지하고, 트랜잭션 간의 충돌을 방지한다. 대표적인 예로는 같은 카운터를 증가시키는 동시성 문제가 있다.

![](https://velog.velcdn.com/images/cksgodl/post/1f1bd6a9-d3bc-4c57-a415-fd9fe23061ad/image.png)

`ACID`에서의 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다. 따라서 데이터베이스는 동시에 여러 트랜잭션이 실행되도 결과가 트랜잭션이 순차적으로 실행됐을 떄의 결과와 동일하도록 보장한다.

- Spring @Transacitonal
- Mongo Transaction
- SQL Transacion

```
격리성 예제 1: 은행 계좌 이체

1. 계좌 A에서 100원 출금.
2. 계좌 B에 100원 입금.
-> 격리성 유지

설명:
- 트랜잭션 T1이 계좌 A에서 출금을 완료하기 전, 트랜잭션 T2가 계좌 A의 잔액을 조회하려고 하면 트랜잭션 충돌이 발생할 수 있음.
- 격리성은 T1이 완료될 때까지 T2가 계좌 A의 잔액에 접근하지 못하도록 보장.
- 이를 통해 데이터 무결성과 일관성을 유지.
```

```
격리성 예제 2: 온라인 쇼핑몰 주문 처리

1. 재고를 확인.
2. 주문을 생성.
3. 재고 수량을 감소.
-> 격리성 유지

- 트랜잭션 T1이 재고를 감소시키는 중에, 트랜잭션 T2가 같은 제품의 재고를 확인하거나 감소시키려 하면 충돌이 발생할 수 있음.
- 격리성은 T1이 완료되기 전, T2가 재고 데이터를 읽거나 수정하지 못하도록 막음.
- 이를 통해 데이터의 신뢰성을 유지.
```


### 지속성 Durability

DB의 중요 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공하는 것이다.

> 따라서 **지속성**은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 디비가 죽더라도 모든 데이터는 손실되지 않는다는 보장이다.

복제 기능이 있는 DB에서 지속성은 데이터가 성공적으로 다른 노드 몇 개에 복사됐다는 것을 의미할 수 있다. 지속성을 보장하려면 DB는 트랜잭션이 성공적으로 커밋됐다고 보고하기전 쓰기나 복제가 완료될 때까지 기다려야 한다. 

## 단일 객체 연산과 다중 객체 연산

이를 요약하자면 `ACID`에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 DB가 어떻게 해야 하는지를 서술한다.

- **원자성**
  - 쓰기를 이어서 실행하는 도중 오류가 발생하면 트랜잭션은 어보트돼야 하고 그때까지 쓰여진 내용은 폐기돼야 한다. 다시 말해 DB는 전부 반영되거나 아무것도 반영되지 않는 것을 보장함으로써 부분 실패를 걱정할 필요가 없게 도와준다. 
- **격리성**
  - 동시에 실행되는 트랜잭션들은 서로를 방해하지 말아야 한다. 예를 들어, 한 트랜잭션이 여러 번 쓴다면 다른 트랜잭션은 그 내용을 전부 볼 수 있든지 아무것도 볼 수 없든지 둘 중 하나여야만 한다.

아래는 다중 객체(도큐먼트)에 대한 객체 연산의 예제이다.

```sql
SELECT COUNT(*) FROM emails WHERE recipient_id = 2 AND unread_flag is true
```

![](https://velog.velcdn.com/images/cksgodl/post/dccaddb4-1413-46fc-968d-96f040b52539/image.png)

위 그림에서 사용자2는 아직 읽지 않은 메시지가 하나 있지만, 아직 메세지 갯수에 대한 업데이트는 이뤄지지 않았기 때문에 읽지 않은 메세지 개수가 0으로 나온다.

> **격리성**은 사용자2가 삽입된 이메일과 갱신된 개수를 모두 보거나 모두 보지 못하게 하고 일관성이 깨진 중간 지점을 보는 일이 없게 해준다.

아래는 원자성의 필요성의 예제이다.

![](https://velog.velcdn.com/images/cksgodl/post/9a35c555-3297-4e95-8f1a-a791e6b0ba54/image.png)

트랜잭션 도중 오류가 발생하면 우편함의 내용과 읽지 않는 메시지 개수가 동기화되지 않을 수 있다. 원자적 트랜잭션에서는 개수갱신을 실패하면 트랜잭션이 어보트되고 삽입된 이메일은 롤백된다.

__**다중 객체 트랜잭션**은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다. __

`RDB`에서 이것은 전형적으로 클라이언트와 `DB` 서버 사이의 `TCP` 연결을 기반으로 한다.
어떤 특정 연결 내에서  `BEGIN TRANSACTION` 문과 `COMMIT` 문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여겨진다.

사실 이 방식은 이상적이지 않다. `TCP` 연결이 끊기면 트랜잭션은 어보트 되야 한다.
클라이언트가 커밋 요청을 보냈지만 서버가 커밋 여부를 확인해주기 전에 연결이 끊긴다면 클라이언트는 트랜잭션이 커밋됐는지 아닌지 알 수가 없다. 이 문제를 해결하기 위해 트랜잭션 관리자는 특정 TCP 연결에 엮이지 않은 **고유한 트랜잭션 식별자**를 사용해 연산을 묶을 수 있다. 

비관계형 데이터베이스는 이런 연산을 묶는 방법이 없는 경우가 많다. 즉, 다중 객체 `API`가 존재하더라도 반드시 트랜잭션 시맨틱을 뜻하지 않는다. 레디스의 `Multi Put`에서 어떤 키에 대한 연산은 성공하고 나머지 키에 대한 연산은 실패해서 DB가 부분적으로 갱신된 상태가 될 수 있다. 

### 단일 객체 쓰기

저장소 엔진들은 거의 보편적으로 한 노드에 존재하는 (키-값 쌍 같은) 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다. 이를 구현하기 위해 다음 방식을 활용한다.

- 원자성은
  - 장애 복구(crash recovery)용 로그를 써서 구현할 수 있다. 
- 격리성은
  - 각 객체에 잠금을 사용해 한 스레드가 점유할 수 있도록 구현할 수 있다. 
  
`compare-and-set` 과 다른 단일 객체 연산은 경량 트랜잭션(light-weight-transaction)으로 불리거나 마케팅 목적으로 ACID 라고 간주되기도 하지만 이런 용어는 오해의 소지가 있다. 트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행단위로 묶는 메커니즘으로 이해된다. 

### 다중 객체 트랜잭션의 필요성

여러 객체에 대한 트랜잭션이 필요할까? 물론 단일 객체 연산만을 제공하여 모든 것을 처리할 수 있다. 하지만, 원자성이 없으면 오류 처리가 훨씬 더 복잡해지고, 격리성이 없으면 동시성 문제가 생길 수 있다 

### 오류와 어보트 처리

트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다. ACID데이터베이스는 이 철학을 기반으로 한다. 

하지만 어보트처리도 완벽하진 않다.

- 커밋 성공을 알리는 도중 에러가 발생하면 트랜잭션이 두 번 실행된다.
- 과부하 때문이라면 트랜잭션은 독이될 수 있다.
- 영구적인 에러는 재시도 해도 소용이 없다.
- 사이드 이펙트가 있다면 어보트 처리시에도 사이드 이펙트가 발생할 수 있다.
- 클라이언트 프로세스가 재시도 중에 죽어버리면 데이터베이스에 쓰려고 한 데이터가 모두 손실된다.

## 완화된 격리 수준

두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않음으로 병렬 실행이 가능하다. 따라서 동일한 데이터에 접근하지 못하게 하는 트랜잭션 격리를 제공함으로 동시성 문제를 해결하였다.

**직렬성** 격리는 데이터베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것(동시성 없이 한 번에 하나의 트랜잭션만 실행)과 동일한 결과가 나온다는 것을 보장한다.

세상에는 모든 걸 완벽히 제공하는 데이터베이스는 없다(어떤 데이터베이스는 에러가 발생한다.) 따라서 격리에 대한 이해하고 이를 활용하자.

아래는 격리를 제공하는 여러 방법에 대해 설명한다.

### 커밋 후 읽기

가장 기본적인 수준의 트랜잭션 격리는 **커밋 후 읽기(read committed)** 이다. 이는 두 가지를 보장해준다.

- 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다. (더티 읽기가 없음)
- 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다. (더티 쓰기가 없음)

#### 더티 읽기 방지 (prevent dirty read)

![](https://velog.velcdn.com/images/cksgodl/post/310336c5-d54f-4179-8ce0-3023b806a432/image.png)

데이터베이스에 쓰기를 했지만 커밋하지 않으면 다른 유저가 읽지 못하게 하는 것을 **더티 읽기 방지** 라고 한다.

커밋 후 읽기에서는 말그대로 커밋을 통해 트랜잭션을 제공한다. 

#### 더티 쓰기 방지 (prevent dirty write)

두 유저가 동시에 동일한 객체를 갱신하고자 하면 **더티 쓰기**가 발생한다.

 ![](https://velog.velcdn.com/images/cksgodl/post/7cd51afa-38ce-4b41-99e6-32e3f18dde0f/image.png)

위의 그림은 더티쓰기의 한 예제이다. 
이는 엘리스와 밥이 동시에 차를 사고자 한다. 웹사이트에 구래 목록이 반영되어야하며, 송장이 전달되어야 한다. 예제에서는 밥에게 판매됐고, 송장은 엘리스에게 전달되었다.

커밋 후 읽기는 이런 문제를 방지한다.

### 커밋 후 읽기 구현

더티 읽기를 방지하기 위해 가장 간단한 방법은 쓰기를 수행하는 동안 로우를 잠그는 것이다. 이는 객체가 변경됐으나 아직 커밋되지 않은 값을 가지고 있을 때 읽기가 수행되는 것을 방지할 수 있다.

그러나 읽기 잠금은 운용성이 나쁘며, 나쁜 연쇄 효과를 미칠 수 있다.

### 스냅숏 격리와 반복 읽기

커밋 후 읽기 격리를 피상적으로 보면 트랜잭션이 해야 하는 모든 일을 해주는 것으로 생각하는 것도 무리가 아니다.

하지만 이도 문제가 있다.

![](https://velog.velcdn.com/images/cksgodl/post/ff9e9991-1226-4262-a139-224c37b4866b/image.png)

위의 그림처럼 읽기가 먼저 발생 후, 업데이트가 되었을 때 앨리스는 500이라는 잘못된 값을 볼 수 있다. 

이런 이상 현상을 **비반복 읽기(nonrepeatable read)**나 **읽기 스큐**라고 한다.

새로고침하면 거의 일관되게 볼 수 있지만 감내할 수 없는 경우도 있다. 그럴 떄는 **스냅숏 격리**를 사용한다.

**스냅숏 격리**는 데이터베이스의 일관된 스냅숏으로부터 읽는다. 즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 모든 데이터를 본다. 나중에 데이터가 바뀌어도 과거 데이터를 볼 뿐이다.

이는 시간이 오래 걸리며 읽기만 하는 실행에 요긴하다. 

### 스냅숏 격리 구현

이는 커밋 후 읽기 처럼 쓰기 잠금을 사용한다. 허나 다른점이 있다면 **읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는 것**이다.

각 데이터베이스는 객체마다 버전 여러개를 유지한다. 진행 중인 트랜잭션에서 다른 시점의 데이터베이스를 봐야할 수도 있기 떄문이다. 이처럼 여러 버전을 함께 유지하는 방식을 **다중 버전 동시성 제어(multi-version concurrency control, MVCC)**라고 한다.

아래 그림은 postGraphQL의 MVCC기반 스냅숏 격리의 예제이다.

![](https://velog.velcdn.com/images/cksgodl/post/275077a4-c7b9-41d4-b896-78664de717b3/image.png)

- 트랜잭션이 시작하면 증가하는 고유한 트랜잭션 `ID`를 할당받는다.
- 트랜잭션이 데이터베이스에 데이터를 쓸 떄마다 쓰기를 실행한 트랜잭션 `ID`가 함께 붙는다.(위의 그림에서 `created_by`)
- 툼스톤(`deleted_by`)도 존재하여 삭제하면 실제로 지우지 않고, 트랜 잭션으로 부터 지워졌다고 표기한다.

### 일관된 스냅숏을 보는 가시성 규칙

트랜잭션은 데이터베이스에서 객체를 읽을 때 트랜잭션 ID를 사용해 어떤 것을 볼 수 있고 볼 수 없는지 결정한다. 

오래 실행되는 트랜잭션은 오랫동안 스냅숏을 사용해서 (다른 트랜잭션의 관점에서) 덮어써지거나 삭제된 지 오래된 값을 계속 읽을 수도 있다. _데이터 베이스는 갱신할 때 값을 교체하지 않고 바뀔때마다 새 버전을 생성함으로써 작은 오버헤드를 감수하고 일관된 스냅숏을 제공한다._

### 색인과 스냅숏 격리

카우치DB, 데이토믹, LMDB의 색인은 B트리를 사용하지만 추가 전용이며 쓸 때 복사되는(append-only/copy-on-write)변종을 사용한다. 트리의 페이지가 갱신될 때 덮어쓰는 대신 각 변경된 페이지의 새로운 복사본을 생성한다. 

트리의 루트에 이르기까지 존재하는 부모 페이지들은 복사되고 그것들의 자식 페이지들의 새 버전을 가리키도록 갱신된다. 쓰기에 영향을 받지 않는 페이지들은 복사될 필요가 없고 변함 없는 상태로 남는다. 

추가 전용 B 트리를 사용하면 쓰기를 실행하는 모든 트랜잭션(or 묶음)은 새로운 B 트리 루트를 생성하며 특정 루트는 그것이 생성된 시점에 해당하는 DB의 일관된 스냅숏이 된다. 나중에 실행되는 쓰기는 새로운 트리 루트만 생성할 수 있고 존재하는 B 트리를 변경할 수 없으므로 트랜잭션 ID를 기반으로 객체를 걸러낼 필요가 없다. 

그러나 이 방법도 컴팩션과 GC를 실행하는 백그라운드 프로세스가 필요하다. 

### 갱신 손실 방지

동시에 트랜잭션이 발생하면 **갱신 손실(lost update)**가 발생할 수 있다. (두 트랜잭션이 동시에 카운터를 증가시키는 예)

갱신 손실 문제는 어플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때(`read-modify-write` 주기) 발생할 수 있다. 두 작업이 동시에 진행되면 한 작업은 손실될 수 있다. 

### 원자적 쓰기 연산

여러 데이터베이스에서 원자적 갱신 연산을 제공한다. 이 연산은 어플리케이션 코드에서 `read-modify-write` 주기를 구현할 필요를 없애준다. 예를 들어 다음 코드는 동시성 안전하다.

```sql
UPDATE counters SET value = value +1 WHERE key = 'foo';
```

몽고DB는 `JSON`문서 일부를 지역적으로 변경하는 원자적 연산을 제공하고, 레디스는 우선순위 큐 같은 원자적 연산을 제공한다. 

> 원자적 연산은 보통 객체를 읽을 때 그 객체에 독점적인 잠금을 획득하여 구현한다. 갱신이 적용될 때 까지 다른 트랜잭션에서 그 객체를 읽지 못하게 한다. 이 방법을 **커서 안정성**이라고 한다.

불행하게도 `ORM`(객체 관계형 매핑 프레임워크)를 사용하면 원자적 연산을 사용하는 대신 불안전한 연산을 실행하기 쉽다. 

### 명시적인 잠금

원자적 연산뿐만 아니라 명시적으로 락을 획득하여 갱신 손실을 막을 수 있다. 그러면 어플리케이션이 `read-modify-write`주기를 수행할 수 있고, 다른 트랜잭션이 동시에 같은 객체를 읽고자 한다면 락에 막힌다.

SQL의 `FOR UPDATE`절을 통해 두 명의 플레이어가 같은 물체를 동시에 움직일 수 없도록 잠금을 할 수 있다.

```sql
BEGIN;

-- 플레이어 1이 물체를 잠그고 움직이기
SELECT * 
FROM game_objects 
WHERE object_id = 1
FOR UPDATE;

-- 플레이어 1로 업데이트
UPDATE game_objects
SET current_player_id = 1, last_updated = CURRENT_TIMESTAMP
WHERE object_id = 1;

COMMIT;
```

### 갱신 손실 자동 감지

원자적 연산과 잠금은 `read-modify-write` 주기가 순차적으로 실행되도록 강제함으로써 갱신 손실을 방지하는 방법이다. 

대안으로는 이들의 병렬 실행을 허용하고 트랜잭션 관리자가 갱신손실을 발견하면 `read-modify-write`주기를 재시도하도록 강제할 수 있다.

### compare-and-set

이는 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용한다. 이전에 읽은 값과 동일하지 않으면 갱신은 반영되지 않고 재시도 한다.

```sql
UPDATE accounts
SET balance = 1500
WHERE account_id = 1 AND balance = 1000;
```

_위의 예시는 DB의 구현에 따라 안전하지 않을 수 있다. (오래된 스냅숏을 읽는 경우라면)_

### 충돌 해소와 복제

레플리카가 적용된 데이터베이스에서 갱신 손실을 막는 것은 쉽지 않다. 잠금과 `compare-and-set`연산은 데이터의 최신 복사본이 하나만 있다고 가정한다. 다중 리더 디비에서는 이 값이 최신 값이라고 보장할 수 없다.

많은 복제 데이터베이스는 **최종 쓰기 승리(LWW)** 충돌 해소 방법을 활용한다. 이는 갱신 손실이 발생하기 쉽지만, 기본 설정이다.

### 쓰기 스큐와 팬텀

> **쓰기 스큐(Write Skew)**는 분산 시스템 또는 데이터베이스에서 발생하는 동시성 문제 중 하나로, 분리된 트랜잭션들이 독립적으로 실행되면서 서로 영향을 주지 않아야 할 데이터에 간접적으로 영향을 미치는 현상이다.

![](https://velog.velcdn.com/images/cksgodl/post/470a35e2-b575-4f81-badc-ffd94c9a1d41/image.png)

위의 예시에서는 밥과 앨리스 모두 on_call상태를 `false`로 변경한다.

### 쓰기 스큐를 특징짓기

두 트랜잭션이 동시에 실행됐기 떄문에 이상 동작이 발생했다.

쓰기 스큐는 두 트랜잭션이 같은 객체를 읽어서 그 중 일부를 갱신할 때 나타날 수 있다.다른 트랜잭션이 하나의 동일한 객체를 갱신하는 경우에 더티 쓰기나 갱신손실 이상 현상을 겪게 된다.

- 쓰기 스큐는 원자적 단일 객체 연산은 도움 되지 않는다. (여러 객체가 관련됨으로)
- 트랜잭션이 의존하는 로우를 명시적으로 잠그는 것이 차선책이다.

### 쓰기 스큐를 유발하는 팬텀

![](https://velog.velcdn.com/images/cksgodl/post/ac5fb48c-0084-4d9a-8edb-289eb92e0055/image.png)

이런 쓰기 스큐의 예에는 비슷한 팬텀이 존재한다.

1. SELECT 질의로 로우를 검색하여 요구사항을 파악한다.
2. 요구사항의 결과에 따라 어플리케이션 작업을 수행한다.
3. 어플리케이션작업의 내용을 DB에 커밋한다.

> 이처럼 어떤 트랜잭션의 쓰기가 다른 트랜잭션의 검색 질의를 바꾸는 효과를 **팬텀**이라고 한다. 

### 충돌 구체화

팬텀의 문제가 락을 걸 객체가 없다는 거라면 인위적으로 데이터베이스에 잠금 객체를 추가할 수 있지 않을까?

이런 방식을 **충돌 구체화**라고 한다. 팬텀을 데이터베이스에 존재하는 구체적인 로우 집합에 대한 잠금 충돌로 변환하기 떄문이다. 이는 구현 및 이해가 어렵기에 최후의 수단으로 고려해야 한다. 대부분의 경우 직렬성 격리 수준이 선호된다.

## 직렬성

> 직렬성 격리는 보통 가장 강력한 격리 수준이라고 여겨진다. 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 **직렬로** 실행될 때와 같도록 보장한다.

즉 데이터베이스가 발생할 수 있는 모든 경쟁 조건을 막아준다. 이렇게 좋은걸 왜안쓸까? 보통 직렬성 격리는 아래 기법들을 사용한다.

- 트랜잭션 순차 실행
- 2단계 락
- 낙관적 동시성 제어

### 실제적인 직렬 실행

동시성 문제를 회피하는 방식은 동시성을 사용하지 않는 것이다. (_금연을 수행하기 위해서는 담배를 안피면 된다._) 하나씩만 직렬로 단일 스레드에서 실행하면 된다. 

뻔한 생각처럼 보이지만 2007년이 되어서야 이것이 실현 가능하다고 결론내렸다. 왜일까?

- 램 가격이 저렴해져서 많은 메모리를 유지할 수 있을 정도가 되었다. 
트랜잭션이 접근해야 하는 모든 데이터가 메모리에 있다면 훨씬더 빨리 실행된다.
- OLTP 트랜잭션이 짧고 실행하는 읽기와 쓰기개수가 적다는 것을 깨달았다.

이러한 방식은 처리량은 CPU코어 하나의 처리량으로 제한된다.

### 트랜잭션을 스토어드 프로시저 안에 캡슐화하기

항공권 예약은 여러 과정(장소선택, 날짜선택, 탑승정보선택, 지불하기등)을 거쳐야 한다. 이러한 모든 과정을 트랜잭션으로 묶으면 정말 좋을 것이다. 하지만 사람의 결정속도는 느리기 떄문에 이는 불가능하다.

따라서 우리는 여러 트랜잭션을 애플리케이션단에서 모아서 트랜잭션 전체를 스토어드 프로시저라는 곳에 제출할 수 있따.

트랜잭션에 필요한 데이터는 모두 메모리에 있고, 스토어드 프로시저는 네트워크나 디스크I/O 대기 없이 매우 빨리 실행된다고 가정한다. 

![](https://velog.velcdn.com/images/cksgodl/post/8b81f593-a861-4769-b7a1-0db576b7a8ba/image.png)

### 스토어드 프로시저의 장단점

- 데이터베이스마다 프로시저용 언어가 다르다.
- 데이터베이스에서 실행되는 코드는 관리하기 까다롭다.
- 데이터베이스는 어플리케이션 서버보다 훨씬 더 성능에 민감할 때가 많다.

현대에는 많이 발전되어 범용 프로그래밍 언어로 프로시저를 작성할 수 있다. 볼트DB는 자바나 그루비를, 데이토믹은 자바나 클로저를, 레디스는 루아를 사용한다.

스토어드 프로시저가 있으면 모든 트랜잭션을 단일 쓰레드에서 실행할 수 있다. I/O대기가 없고, 다른 동시성 제어 메커니즘의 오버헤드를 회피함으로 좋은 처리량을 제공할 수 있다.

> __하지만 레디스는 기본으로 단일쓰레드로 동작한다.__
> 
- 메모리 데이터베이스 
   - 최적의 CPU 캐싱 활용
- 키-값 모델 -> 조회속도 O(1)
- 비동기 I/O 모델 (Multiplexing)
   - 하나의 쓰레드로 여러 클라이언트에 대한 IO 처리 가능
- 컨텍스트 스위칭 부하 감소 (락이 존재하지 않음)
- 용도에 최적화된 자료 구조
- 대량 데이터 전송에는 쥐약
- 일부 연산은 다중 쓰레드로 동작 (lazy-free 기법)

### 파티셔닝

각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티셔닝할 수 있다면 각 파티션은 다른 파티션과 독립적으로 실행되는 자신만의 트랜잭션 처리 스레드를 가질 수 있다.

하지만, 여러 파티션에 접근해야 하는 트랜잭션이 있을 경우,  DB는 해당 트랜잭션이 접근하는 모든 파티션에 걸쳐 코디네이션을 해야 한다. 스토어드 프로시저는 전체 시스템에 걸쳐 직렬성을 보장하기 위해 모든 파티션에 걸쳐 잠금을 획득한 단계에서 실행돼야 한다.

여러 파티션에 걸친 트랜잭션은 추가적인 코디네이션 오버헤드가 있기에 단일 파티션 트랜잭션보다 매우 느리다. 단순한 키-값 데이터는 파티셔닝이 쉽지만, 여러 보조 색인이 있는 데이터는 여러 파티션에 걸친 코디네이션이 많이 필요할 수 있다. 

### 직렬 실행 요약

트랜잭션 및 실행은 몇 가지 제약 사항 안에서 직렬성 격리를 획득하는 실용적인 방법이 됐다.

- 모든 트랜잭션은 작고 빨라야 한다. 
- 쓰기 처리량이 단일 CPU코어에서 처리할 수 있을 정도로 낮아야 한다. 그렇지 않다면 여러 파티션에 걸친 코디네이션이 필요하지 않도록 트랜잭션을 파티셔닝 해야한다.

### 2단계 잠금 *

30년동안 데이터베이스에서 직렬성을 구현하는 데 널리 쓰인 알고리즘이 있다. 바로 **2단계 잠금**이다.

> 2단계 잠금과 2단계 커밋은 다르다.

앞에서 더티 쓰기를 막는데 잠금이 사용된다고 하였다. 두 개의 트랜잭션이 동시에 같은 데이터 쓰기를 하면 잠금은 나중에 쓰는 쪽이 진행하기 전에 먼저 쓰는 쪽에서 트랜잭션을 완료할 때까지 기다리도록 보장한다.

2단계 잠금도 비슷하지만 요구사항이 훨씬 더 많다. `2PL`에서 쓰기 트랜잭션은 다른 쓰기 트랜잭션뿐만 아니라 읽기 트랜잭션도 진행하지 못하게 막고 그 역도 성립한다. 

> 스냅숏 격리는 **읽는 쪽은 결코 쓰는 쪽을 막지 안흥며 쓰는 쪽도 결코 읽는 쪽을 막지 않는다**라는 원칙이 있는데 2PL은 모두 막아버린다. 이것이 중요한 차이이다.

### 2단계 잠금 구현

이러한 잠금은  **공유 모드(shared mode)**나 **독점 모드(exclusive mode)**로 활용된다.

- 트랜잭션이 객체르 읽기 원한다면 공유 모드로 잠금을 얻어야 한다. 여러 트랜잭션이 공유 모드로 잠금을 얻는 것은 허용되지만 그 객체에 이미 독점 모드로 잠금을 획득한 트랜잭션이 있다면 다른 트랜잭션은 기달려야 한다.
- 트랜잭션이 객체에 쓰기를 원한다면 먼저 독점 모드로 잠금을 획득해야 한다. 다른 어떤 트랜잭션도 동시에 잠금을 획득할 수 없다.
- 트랜잭션이 객체를 읽다가 쓰기를 실행할 때는 공유 잠금을 독점 잠금으로 업그레이드해야 한다. 
- 트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료될때 까지 잠금을 가지고 있어야 한다. 

>잠금이 아주 많이 사용됨으로 트랜잭션 A는 트랜잭션 B가 잠금을 해제하기를 기다리느라 멈추고, 트랜잭션 B가 트랜잭션 A의 잠금을 해제하기를 기다리는 데드락 현상이 일어날 수 있다. 
>
> 데이터 베이스 단에서 이를 감지하고 한 트랜잭션을 어보트 시킨다.

### 2단계 잠금의 성능

2단계 잠금을 쓰면 처리량과 응답 시간이 매우 나빠진다. 원인 중 하나는 동시성을 많이 잃어버리는 것이다. 경쟁 조건이 2배로 생기기 때문이다.

전통형 관계형 DB는 트랜잭션의 실행 시간을 제한하지 않는다. 따라서 하나의 트랜잭션만 느려도 시스템이 전체적으로 느려진다.

교착 상태또만 자주 발생한다.

### 서술 잠금

한 트랜잭션이 다른 트랜잭션의 검색 질의 결과를 바꿔버리는 문제를 방지해야 한다. 이를 **서술 잠금(predicate lock)**을 활용해 구현한다. 이는 **공유/독점 잠금**과 비슷하게 동작하지만 특정 객체에 속하지 않고 조건에 부합하는 모든 객체를 잠근다.

```sql
-- postSQL 예시
-- 두 개의 키를 기반으로 잠금 설정
SELECT pg_advisory_lock(1, 2);

-- 작업 수행
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;

-- 트랜잭션 종료 시 자동으로 잠금 해제
COMMIT;
```

여기서 핵심 아이디어는 서술 잠금은 미래에 추가될 수 있는 객체(팬텀)에도 적용될 수 있다. 2단계 잠금이 서술 잠금을 포함하면 모든 형태의 쓰기 스큐와 경쟁 조건을 막을수 있어 직렬성 격리가 된다.

### 색인 범위 잠금

유감스럽게도 서술 잠금은 잘 동작하지 않는다. 다른 트랜잭션이 획득한 잠금이 많으면 시간이 오래 걸린다. 따라서 대부분의 데이터베이스는 **색인 범위 잠금(index-range locking, 다음 키 잠금(next-key locking)**을 구현한다.

범위 잠금을 잡을 수 없는 적합한 색인이 없다면 데이터베이스는 테이블 전체에 공유 잠금을 잡는것으로 대체할 수 있다. (성능에는 안좋다.)

> 다시보는 쓰기스큐와 팬텀
>
> 쓰기 스큐 : 두 개 이상의 다른 트랜잭션이 하나의 데이터를 쓸 때 발생
> 팬텀 : 범위 쿼리를 조회했을 때 이전에는 없던 새로운 행이 나타나는 현상

### 직렬성 스냅숏 격리(SSI)

지금까지 데이터베이스의 암울한 동시성 제어에 대해 알아봤다. 성능이 좋지 않거나(2단계 잠금), 확장이 되지 않거나(직렬 실행), 성능이 좋지만 문제가 있거나(갱신 손실, 쓰기 스큐, 팬텀) 등의 격리 수준이 있다.

하지만 직렬성 격리와 좋은 성능은 공존할 수 있다. 바로 **직렬성 스냅숏 격리(serializable snapshot isolation, SSI)**라는 알고리즘이 유망하다. 

오늘날 SSI는 단일 노드 데이터베이스와 분산 데이터베이스 모두 사용한다. 이에 대해 다음에서 설명한다.

### 비관적 동시성 제어 대 낙관적 동시성 제어

2단계 잠금은 이른바 **비관적** 동시성 제어 메커니즘이다. (다른 트랜잭션이 획득한 잠금을 기다린다) 뭔가 잘못될 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해질 때 까지 기다리는게 낫다라는 원칙을 기반으로 한다. (상호 배제(`mutual exclusion`)과 비슷하다.

따라서 비관적 동시성 제어는 트랜잭션을 빠르게 해서 락의 유지 시간을 줄이는 방법으로 보완한다.

반대로 직렬성 스냅샷 격리는 **낙관적** 동시성 제어 기법이다. 이 트랜잭션은 뭔가 상황이 발생할 가능성이 있을 때 트랜잭션을 막는 대신 모든 것이 괜찮아질 거라는 희망을 갖고 계속 진행한다. 따라서 트랜잭션이 커밋될 때 데이터베이스는 나쁜 상황이 발생했는지를 체크한다. 

트랜잭션이 많으면 어보트시켜야할 트랜잭션이 많아지고, 트랜잭션이 많이 없으면 비관 적 동시성 제어보다 성능이 좋은 경향이 있다.

> `SSI`는 스냅숏 격리를 기반으로 한다. 즉 트랜잭션 중 읽기는 스냅숏을 보게 된다. `SSI`는 스냅숏 격리 위에 쓰기 작업 사이의 직렬성 충돌감지 알고리즘을 추가한다.

### 뒤처진 전제에 기반한 결정

트랜잭션을 실행할 때 어떤 상황이 나중에 트랜잭션을 커밋할 때 바뀌어서 올바른 동작이 일어나지 않을 수 있다. 따라서 직렬성 격리를 제공하려면 트랜잭션이 뒤쳐진 전제를 기반으로 동작하는지 체크하고 어보트 해야한다.

이를 알기 위해서 두 가지 상황을 고려한다.

- 오래된 MVCC 객체 버전을 읽었는지 감지하기(읽기 전에 커밋되지 않은 쓰기 발행)
- 과거의 읽기에 영향을 미치는 쓰기 감지하기(읽은 후에 쓰기가 실행됨)

### 오래된 MVCC 읽기 감지하기

스냅숏 격리는 보통 다중 버전 동시성 제어(`MVCC`)를 기반으로 구현된다. 트랜잭션이 MVCC 데이터베이스에서 스냅숏을 읽으면 다른 트랜잭션이 쓴 데이터를 읽지 못한다. 

![](https://velog.velcdn.com/images/cksgodl/post/e749052a-4f0a-403f-adc2-bb4b641d1be6/image.png)

트랜잭션이 커밋하려고 할 때 데이터베이스는 무시된 쓰기 중에 커밋된 게 있는지 확인한다. 커밋된게 있다면 트랜잭션은 어보트 된다.

왜 낙관적 제어는 커밋할 때 까지 기다릴까? 트랜잭션 43이 읽기 전용 트랜잭션이라면 쓰기 스큐의 위험이 없으므로 어보트될 필요가 없다. _(트랜잭션 43이 읽기를 실행하는 시점에 데이터베이스는 그 트랜잭션이 나중에 쓰기를 실행하는지 알 수 없다.)_

> 따라서 `SSI`는 불필요한 어보트를 피하기 위해 커밋 시 다른 트랜잭션을 검사한다.

### 과거의 읽기에 영향을 미치는 쓰기 감지하기

데이터를 읽은 후 다른 트랜잭션에서 그 데이터를 변경할 수도 있다.

![](https://velog.velcdn.com/images/cksgodl/post/32b34163-9ad8-475c-889c-f4757dd0f76b/image.png)

`SSI`잠금도 인덱스 범위 잠금과 비슷한 기법을 활용한다.

위의 그림에서 트랜잭션 42, 43 모두 아이디 1234의 호출 대기 의사를 질의한다. 데이터베이스는 인덱스 1234에 대해 트랜잭션 42, 43이 해당 데이터를 읽었다는 사실을 기록할 수 있다. 트랜잭션이 완료되고(커밋 or 어보트) 동시에 실행되는 모든 트랜잭션들이 완료된 후에 데이터베이스는 어떤 트랜잭션이 어떤 데이터를 읽었는지 지워도 된다.

트랜잭션이 데이터베이스에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 확인한다. 이는 다른 트랜잭션이 커밋될 때 까지 차단하지 않으며, 커밋될 때 최신 데이터가 아니라고 알린다.

### 직렬성 스냅숏 격리의 성능

스냅숏 격리는 다른 잠금과 비교하여 큰 이점은 다른 트랜잭션들이 잡고있는 잠금을 기다릴 필요가 없다는 것이다. 쓰는 쪽도 읽는 쪽을 막지 않고, 읽는 쪽도 쓰는 쪽을 막지 않는다. 이런 설계로 인해 질의 시간 예측이 쉽고 변동이 적다. 특히 읽기 질의는 어떤 잠금도 없이 일관된 스냅숏 위에서 실행된다.

이는 단일 CPU코어의 처리량에 제한되지 않는다. 따라서 파티셔닝 되어있는 장비라도 직렬성 격리를 보장하며 데이터를 읽고 쓸 수 있다.

어보트 비율은 성능에 크게 영향을 미친다. 오랜 데이터를 읽고 쓰는 트랜잭션은 어보트되기 쉬워서 `SSI`는 짧은 트랜잭션을 선호한다.

## 정리

트랜잭션은 어플리케이션이 동시성 문제가 일어나지 않는 것 처럼 동작하게 하는 추상층이다. 많은 종류의 오류가 간단한 **트랜잭션 어보트**로 줄어들도 어플리케이션은 재시도만 하면 된다.

이번장에서 발생하는 여러 단어를 잘 기억하자.

#### 더티 읽기

한 클라이언트가 다른 클라이언트가 썼지만 아직 커밋되지 않는 데이터를 읽는다. 커밋 후 읽기 또는 그보다 강한 격리 수준은 더티 읽기를 방지한다.

#### 더티 쓰기

한 클라이언트가 다른 클라이언트가 썼지만 아직 커밋되지 않는 데이터를 덮어쓴다. 거의 모든 트랜잭션 구현은 더티쓰기를 방지한다.

#### 읽기 스큐(비반복 읽기)

클라이언트가 다른 시점의 데이터베이스를 본다. 
이 문제를 막기위한 해결책으로 트랜잭션이 어느 시점의 일관된 스냅숏으로 읽는 스냅숏 격리를 가장 흔히 사용한다. 보통 **다중 버전 동시성 제어(MVCC)**를 써서 구현한다.

#### 갱신 손실

두 클라이언트가 동시에 `read-modify-write` 주기를 실행한다. 한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은 채로 쓴 내용을 덮어써서 데이터가 손실된다.

#### 쓰기 스큐

트랜잭션이 무언가를 읽고 읽은 값으로 어떤 결정을하고 데이터베이스에 쓴다. 그러나 쓰기를 실행하는 시점에는 결정의 전제가 참이 아니다. 
직렬성 격리만 이런 현상을 막을 수 있다.

#### 팬텀 읽기

어떤 검색 조건에 부합하는 객체를 읽는다. 다른 클라이언트가 그 검색 결과에 영향을 주는 쓰기를 실행한다. 다시 검색했을 때 이전에는 없던 행이 나타난다. 
쓰기 스큐 맥락에서 발생하는 팬텀은 색인 범위 잠금처럼 특별한 처리가 필요하다.

---

직렬성 격리만 이 모든문제들로부터 보호해준다. 직렬성 트랜잭션을 구현하는 세 가지 방법을 설명했다.

#### 트랜잭션을 순서대로 실행하기

트랜잭션을 순서대로 실행한다. 처리량은 단일 CPU코어로 실행된다.

#### 2단계 잠금

잠금을 2단으로 설정한다. 성능이 아주 느리다.

#### 직렬성 스냅숏 처리(SSI)

낙관적 방법을 사용하여 트랜잭션이 차단되지 않고 진행할 수 있게 한다. 트랜잭션이 커밋을 원할 때 트랜잭션을 확인해서 실행이 직렬하지 않다면 어보트한다.
