오늘날 하드웨어의 발전으로 인해 **계산 중심**보다는 **데이터 중심**적으로 어플리케이션 설계가 변경되고 있다.

데이터 중심 세계는 역사적으로 다음과 같은 컴포넌트로 구성된다. 

- 데이터베이스
- 캐시
- 검색 색인(인덱스)
- 스트림 처리
- 일괄 처리

해당 책에서는 위의 컴포넌트에 대한 원칙, 실용성과 이를 활용하면 데이터 중심 어플리케이션을 구성하는 방법을 알아본다.

## 데이터 시스템에 대한 생각

첫 번째로, 데이터 저장과 처리를 위한 여러 컴포넌트는 비교적 최근에 만들어 졌다. 따라서 유즈케이스에 따라 다른 도구를 활용할 수 있다. 새로운 도구의 발달로 인해 이런 분류 간 경계가 흐려지고 있다.

> 예를 들어 메시지 큐로 사용하는 레디스, 데이터베이스처럼 지속성을 보장하는 메시지 큐인 아파치 카프카도 있다.
> ![](https://velog.velcdn.com/images/cksgodl/post/76b4eefd-22e3-48aa-8ac1-b0ee140f841c/image.png)
>
> ![](https://velog.velcdn.com/images/cksgodl/post/d90409b4-8125-4d2c-874b-36497e9cc44d/image.png)

두 번째로 많은 어플리케이션이 단일 도구로는 더이상 처리 및 저장을 모두 만족할 수 없는 요구사항을 가지게 됐다. 따라서 작업은 단일 도구에서 효율적으로 실행할 수 있는 태스크로 나누고, 다양한 도구들은 어플리케이션 코드를 이용해 서로 연결한다.

---

데이터 시스템이나 서비스의 설계는 까다로운 문제가 많이 생긴다. 이 책에서는 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사에 중점을 둔다.

- 신뢰성
- 확장성
- 유지보수성 

## 신뢰성

잘못될 수 있는 일을 **결함(fault)**라고 한다. 결함을 예측하고 대처할 수 있는 시스템을 **내결함성(fault-tolerant) 또는 탄력성(resilient)**를 지녔다고 말한다.

결함은 장애와 동일하지 않다. 결함은 예상에 벗어난 사용자 응답과 같이 언제든 발생할 수 있는 유형의 문제이지만, **장애**는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우로 정의한다.

> 따라서 대개 결함으로 인한 장애가 발생하지 않는 내결함성 구조를 설계하는 것을 목표로 한다.

넷플릭스의 장애 발생 오픈소스인 카오스몽키가 탄력성에 대한 대표적인 예이다. 

- [블로그 글](https://netflixtechblog.com/the-netflix-simian-army-16e57fbab116)을 보면 카오스 몽키라는 재미있는 이름은 “무기를 든 야생 원숭이가 데이터센터(또는 클라우드 영역)에 들어와 무작위로 인스턴스를 파괴하고 케이블을 끊더라도 중단 없이 고객에게 서비스를 계속 제공한다는 개념”에서 유래됐다.

### 하드웨어 결함

카오스 몽키와 같은 예가 등장한 대표적인 이유로 시스템 장애의 대표적인  이유는 하드웨어 결함이다. 큰 대규모데이터센터에서 동작하는 많은 장비의 경우 정전, 램의 결합 등의 상태는 늘상 일어난다.

하드웨어에 따른 시스템 장애를 줄이기 위해서는 하드웨어에 중복(`redundancy`)을 추가하는 방식이 일반적이다. 디스크 RAID 구성, 핫 스왑 구조, 예비 디젤 발전기가 이런 하드웨어 중복을 의미한다.

- [redundancy와 replica?](https://reoim.tistory.com/entry/Redundancy-%EC%99%80-Replication-%EC%B0%A8%EC%9D%B4%EC%A0%90)

> 데이터 양과 어플리케이션 요구가 늘어나면서 많은 장비가 사용되게 되었고, 최근에는 단일 장비의 신뢰성보다 유연성과 탄력성을 기반으로 설계된다.

### 소프트웨어 오류 + 인적 오류

- 특정 잘못된 입력이 들어왔을 떄 모든 어플리케이션이 죽는 오류
- CPU, 메모리를 과도하게 사용하는 일부 프로세스
- ANR을 일으키는 특정 화면

이런 소프트웨어 오류는 신속한 해결책이 없다. 빈틈없는 테스트, 주의 깊은 코드리뷰, 오류 전파를 막기 위한 프로세스 격리 프로덕션 환경 모니터링 등을 활용하라.

## 확장성

확장성은 사용자, 트래픽, 데이터 량이 증가했을 때 대처하는 시스템 능력을 의미한다. 이러한 확장성을 계산하고 대처하기 위해서는 부하 및 성능을 측정해야 한다.

### 부하 기술하기

부하는 웹 서버의 초당 요청 수(tps), DB읽기 대 쓰기 비율, 캐시 적중률 등의 요소를 고려하여 **부하 매개변수(load parameter)**를 정의하여 나타낼 수 있다.

### 성능 기술하기

부하를 측정하였으면, 현재 시스템에서의 성능을 기술해야 한다. 

- 부하 매개변수를 증가시켰을 때 시스템 자원을 변경하지 않으면 시스템 성능은 어떻게 영향 받을까?
- 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 늘려야 할까?

이러한 성능 수치는 컴포넌트마다 다르게 기술된다. 하둡의 경우는 처리량, 광고의 경우는 서비스 응답 시간이 중요하게 측정된다.

> 지연 시간(latency)와 응답 시간(response time)
>
> 응답 시간은 클라이언트의 입장에서 API 응답시간을 의미하고, 지연 시간은 요청이 처리되기 기다리는 시간으로, API응답 시 데이터베이스 저장 및 캐시 등록 등의 소요 시간을 의미한다.
>
> 큐 대기 지연과 같은 소수의 지연 시간으로 후속 요청 처리가 지연될 수 있다. 이를 **선두 차단(head of line blocking)**이라고 한다.

클라이언트가 몇 번이고 동일한 요청을 하여도 매번 응답시간은 다르다. 따라서 응답시간은 단일 숫자가 아니라 측정 가능한 값의 **분포**로 생각해야 한다.

![](https://velog.velcdn.com/images/cksgodl/post/b53adbda-3ae8-46b2-86e4-de6882b5c388/image.png)

서비스의 평균 응답시간은 대개 **산술 평균(모든 값 / n)**이 아니라 백분위를 사용한다.

위의 그림에서 중앙값은 `p50`으로 축약할 수 있고, 보통 95분위, 99분위, 99.9분위로 표현한다. _99분의 응답시간이 1.5초라면 100개의 요청 중 99개는 1.5초 이내에 처리된다._

> **꼬리 지연 시간(tail latency)**이라고 불리기도 하며 해당 백분위 응답 시간은 사용자 경험에 직접 영향을 주기에 중요하다.

예를 들어 아마존의 응답 시간 요구사항은 99.9분위로 기술한다. 이런 백분위는 **서비스 수준 목표(service level objective, SLO)**와 **서비스 수준 협약서(service level agreement, SLA)**에 자주 사용하고 기대 성능과 서비스 가용성을 정의하는 계약서에 주로 사용된다.

### 부하 대응 접근 방식

부하에 대응하기 위해서 **수직 확장(vertical scaling) 및 수평 확장(horizontal scaling)**이 존재한다.

대개 장비를 업그레이드 하는 수직 확장은 비용대비 가성비가 좋지 않아 수평 확장을 활용하며, 이를 통해 탄력성을 증가시킨다.

다수의 장비에 상태 비저장(stateless) 서비스를 배포하는 일은 간단하다. 하지만 단일 노드에 상태 유지(stateful) 데이터 시스템을 분산 설치하는 일은 많은 복잡하다. 따라서 주로 상태유지가 필요한 요구는 단일 노드를 통해 구현하는 것이 최근까지의 통념이다.

## 유지보수성

개발자는 **레거시** 시스템 유지보수 작업을 좋아하지 않는다. 한물 간 플랫폼에 작업해야 하는 것은 최악이다. 하지만 이를 바꾸는 것은 더더욱 어렵다. 

따라서 유지보수 중 고통을 최소화하고 레거시 소프트웨어를 직접 만들지 않게끔 소프트웨어를 설계하는 것이 필수이다. 아래는 주의를 기울여야 할 소프트웨어 시스템 설계 원칙을 제공한다.

- 운용성
- 단순성
- 발전성(확장성)

위와 같은 키워드로 클린코드, Tidy First와 같은 책에서 자세한 방법을 다루고 있기에 아래에서는 간단하게 기술한다.

### 운용의 편리함을 위해 : 운용성

> 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다.

좋은 운영의 예를 알아보자.

- 시스템 상태를 모니터링
- 성능, 장애등의 문제 원인을 추적
- 보안 패치를 포함해 최신버전 유지
- 시스템간의 결합성 제거
- 배포, 설정 관리 등 모범 사례 구축
- 부서 이동을 대비한 문서화 제공

### 복잡도 관리 : 단순성

복잡도 수렁에 빠진 어플리케이션을 커다란 진흙 덩어리(big ball of mud)로 표현하기도 한다. 복잡도는 다양한 증상으로 나타나며 네이밍, 커플링, 특수 사례 등 깨끗하지 못한 코드에 의해 주로 증가한다.

__복잡도를 줄이기 위한 최상의 도구는 추상화이다.__ 좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.


### 쉽게 변화하기 위한 : 발전성(확장성)

코드뿐만 아니라 시스템 또한 독립적이고 애자일하게 작성하라.

## 정리

데이터 중심 어플리케이션을 고려하는 몇 가지 기본적인 방법을 알아보았다.

- 신뢰성
결함이 발생해도 장애가 발생하지 않아야 한다.

- 확장성
부하가 증가해도 좋은 성능을 유지할 수 있어야 한다.

- 유지보수성
시스템을 추상화하여 쉽게 시스템을 변경할 수 있게 하라.











