데이터가 너무 많다면 복제만으로 부족하고 데이터를 파티션으로 쪼개야한다. 이를 "샤딩"이라고 한다.

각 파티션은 그 자체로 작은 데이터베이스가 된다.


## 파티셔닝과 복제

![](https://velog.velcdn.com/images/cksgodl/post/49bfa61a-9073-41f4-8f6d-0bccefb633ae/image.png)

파티셔닝과 복제는 보통 같이 적용된다. 같은 파티션내에서 복제를통해 여러 레플리카를 생성한다. 이에따라 각 노드는 어떤 파티션에게는 리더이면서, 어떤 파티션에게는 팔로워가 될 수 있다. 

## key-value 파티셔닝(샤딩)

특정 파티션이 데이터를 많이 받으면 이를 쏠렸다(`skewed`)라고 말한다. 쏠림이 있으면 해당 파티션을 **핫스팟** 이라 한다.

이를 해결하기 위한 방법을 알아보자..

### 키 범위 기준 파티셔닝(샤딩)

![](https://velog.velcdn.com/images/cksgodl/post/5e76985c-07d6-44ea-b8f1-d5fd6329d521/image.png)

- 키 범위는 반드시 동일할 필요가 없다. 데이터가 고르게 분포하지 않을 수 있기 때문이다. 
- 각 파티션의 데이터는 정려된 순서로 저장할 수 있다.

### 키 해시값 기준 파티셔닝

해시 함수는 암호적으로 강력할 필요는 없다. 몽고DB는 `MD5`를 활용하고, 카산드라는 `Fowler-Noll_vo`를 활용한다. 

![](https://velog.velcdn.com/images/cksgodl/post/d341e1a5-87ca-4fe9-a59d-7b507f2ffe5b/image.png)

- 이 기법은 키를 파티션 사이에 균일하게 분산시키는데 좋다. 
- 파티션 경계는 크기가 동일하도록 나눌 수도 있고 무작위에 가깝게 선택할 수도 있다. 
- 범위 질위가 힘들다. (모든 파티션에 질의가 전송되어야 하기에)

#### 몽고의 MD5

> MD5(`Message-Digest Algorithm 5`)는 해시 함수로, 입력 데이터를 고정된 128비트(16바이트) 해시 값으로 변환한다.

`@ShardKey`로 지정된 키에대해 MD5해시함수를 활용하여 샤딩을 진행한다. 이는 데이터 분산이 주목적이기 때문에 암호화보다는 균등한 분포를 위해 사용한다.

추가적으로 몽고의 `ObejctId`의 생성은 해시함수와는 관련이 없다. 아래는 `ObjectId`의 구성이다. 

- 타임스탬프 (Timestamp) 4바이트
  - UNIX epoch로부터의 초 단위 시간.
- 머신 식별자 (Machine Identifier) 5바이트
  - 호스트(서버/클라이언트)를 고유하게 식별하는 값.
- 프로세스 ID (Process ID)	3바이트
  - 동일 머신에서 실행 중인 프로세스를 구분하는 값.
- 카운터 (Counter) 3바이트
  - 같은 프로세스 내에서 ObjectId의 중복 방지를 위한 값.
  - 3바이트 임으로 16,777,216개까지 증가 가능 (2**24)

동일한 머신 식별자를 가진 머신에서, 동일한 프로세스 ID로, 동일한 초에, 동일한 카운터 값으로 ObjectId가 생성되면 `Duplicate Key Error`를 반환한다.

### 쏠린 작업부하와 핫스팟 완화

수만명의 팔로워를 가진 한 유명인이 무슨일을 하면 후폭풍이 발생할 수 있다. 이는 쏠린 작업부하를 만들어 낼 수 있다. 

![](https://velog.velcdn.com/images/cksgodl/post/0830541f-1d84-4b1c-b6a0-307a344a986e/image.png)

해당 소수 키에 대해서 어플리케이션 단에서 추가 작업을 통해 부하를 덜 수 있다.

## 파티셔닝과 보조 색인

샤딩에 보조색인이 연관되면 복잡해진다. 이런 보조 색인이 있는 데이터베이스를 파티셔닝하는데 널리 쓰이는 두 가지 방법이 있다. 문서 기반 파티셔닝과 용어 기반 파티셔닝이다.

### 문서 기준 보조 색인 파티셔닝

![](https://velog.velcdn.com/images/cksgodl/post/84e10a49-4405-4d04-a7ad-6ae0eb593ca5/image.png)

이는 각각의 파티션에 보조 색인을 추가적으로 저장한다. 따라서 질의는 모든 파티션에 보내야 하지만, 각 파티션은 독립적으로 동작한다. 따라서 이를 **지역 색인(local index)** 라고 부르기도 한다.

이는 빨간색인 자동차들이 동일 파티션에 저장될꺼란 보장은 없다.

파티셔닝된 데이터베이스에 질의를 보내는 방식을 **스캐터/개더(scatter/gather)** 라고도 한다. 

### 용어 기준 보조 색인 파티셔닝

![](https://velog.velcdn.com/images/cksgodl/post/8e493b89-3da0-4a91-ac74-f609fb2cbe6a/image.png)

이는 모든 파티션의 데이터를 담당하는 전역 색인을 만든다. 

위의 그림과 같이 찾고자 하는 키(용어)에 따라 색인의 파티션이 결정되므로 이를 **용어 기준 파티션**이라 한다. 이는 읽기에 효율적이지만 쓰기는 복잡하고 느리다. 

또한 색인과 데이터가 다른 파티션에 위치하기에 트랜잭션을 지원하지 않는다.

#### 몽고의 보조 색인에 대하여

몽고는 문서 기준 방식을 채용한다.

> `MongoDB`는 문서 중심 설계 철학에 따라 문서 기준 보조 색인 파티셔닝을 기본으로 사용한다. 이는 문서 지향 데이터 모델의 특성에 부합하며, 데이터의 필드 기반 검색과 확장성에 최적화된 방식이다. 

## 파티션 재균형화

시간이 지나면 데이터베이스에 변화가 생긴다.

- 질의 처리량이 증가하여 늘어난 부하를 처리하기 위해 CPU를 더 추가하고 싶다.
- 데이터셋 크기가 증가하여 디스크 및 램 추가하고 싶다.
- 장애가 발생하여 다른 장비로 이동해야 한다.

이런 상황에서 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 **재균형화(rebalancing)**이라 한다.

### 재균형화 전략

#### 쓰면 안되는 방법 : 해시값에 모드 N연산 실행

노드 개수 N이 바뀌면 대부분 키가 노드 사이에 옮겨져야 한다. -> 이는 리밸런싱 비용이 지나치게 커진다.

#### 파티션 개수 고정

파티션을 노드보다 많이 만들고 각 노드에 여러 파티션을 할당할 수 있다. 이를들어 노드 10대로 구성된 클러스터에서 실행되는 파티션을 1000개로 쪼개어 각 노드마다 100개의 파티션을 할당할 수 있다. 

![](https://velog.velcdn.com/images/cksgodl/post/4fec0678-6719-404b-825e-05ddf25f3106/image.png)

파티션은 노드 사이에서 이동하기만 한다. 이러한 방식은 엘라스틱서치에서 사용된다. 

#### 동적 파티셔닝

키 파티션 범위가 고정돼 있으면 매우 불편하다. 따라서 `HBase`는 파티션을 동적으로 만든다. 각각의 파티션 크기가 임곗값 아래로 떨어지면 인접한 파티션과 합치거나 나눈다. 

동적 파티셔닝은 파티션 개수가 전체 데이터 용량에 맞춰 조정된다. 데이터 양이 작으면 파티션 개수가 적어도 되므로 오버헤드도 작다. 데이터 양이 거대하다면 개별 파티션 크기는 설정된 최대치로 제한된다.

비어있는 DB는 파티션 경계를 어디로 할지에 대해 사전 정보가 없다. 따라서 데이터셋이 작을 땐 모든 쓰기 요청이 하나의 노드에서 실행된다. 몽고DB에선 비어있는 DB에 초기 파티션 집합을 설정할 수 있도록 하며 이를 사전 분할(`pre-splitting`)이라 부른다.

#### 노드 비례 파티셔닝

동적 파티셔닝에서는 파티션 분할과 병합을 통해 개별 파티션 크기가 어떤 고정된 최솟값과 최대값 사이로 유지하게 한다.

카산드라에서는 파티션 개수가 노드 대수에 비례하게 변한다. 즉, 노드당 할당되는 파티션 개수를 고정한다. 

새 노드가 클러스터에 추가되면 고정된 파티션을 무작위로 선택해 분할하고 데이터의 절반을 할당 받는다. 

파티션 경계를 무작위로 선택하고자 한다면 해시 기반 파티셔닝을 사용해야 한다.  

#### 운영: 자동 재균형화와 수동 재균형화

재균형화를 자동으로 수행하면 손이 덜 가므로 편리할 수 있다. 하지만 예측하기 어렵기 떄문에 어느정도는 사람이 개입하는게 좋을 수도 있다.

## 요청 라우팅

파티션이 재균형화 되며 노드에 할당되는 파티션이 변경될 때 클라이언트는 어떻게 파티션을 찾을 수 있을까? 대표적인 방법으로 아래와 같은 방법이 있다.

1. 클라이언트가 아무 노드에 접속하게 한다. -> 해당 노드에 파티션이 있으면 데이터를 읽고 없으면 올바른 노드의 데이터를 클라이언트에게 전달한다.

![](https://velog.velcdn.com/images/cksgodl/post/ab1d0195-270e-4bc7-93a1-269eb184dbe1/image.png)

2. 클라이언트의 모든 요청을 라우팅 계층으로 보낸다. 각 라우팅 계층은 로드밸런서 역할을 수행하여 요청을 전달한다.

![](https://velog.velcdn.com/images/cksgodl/post/664e319b-923b-46e2-8487-fcd63570c2ce/image.png)

3. 클라이언트가 파티셔닝 방법과 어떤 노드에 있는지 알고 있게 한다.

![](https://velog.velcdn.com/images/cksgodl/post/7fcaf0e5-13c2-4dca-bc10-b995cbdf41a5/image.png)

많은 분산 시스템은 메타데이터를 추적하기 위해 주키퍼와 같은 별도의 코디네이션 서비스를 사용한다. 각 노드는 주키퍼에 자신을 등록하고 주키퍼는 타피션과 노드 사이의 신뢰성 있는 할당 정보를 관리한다.

![](https://velog.velcdn.com/images/cksgodl/post/253a39bb-47a8-4cb8-81ee-586ee34df6f4/image.png)

몽고DB는 아키텍쳐는 비슷하지만 자체적인 **설정 서버(config server)** 구현에 의존하고 **몽고스(mongos)**데몬을 라우팅 계층으로 사용한다.

### 병렬 질의 샐행

분석용으로 자주 사용되는 **대규모 병렬 처리(massively parallel processing, MPP)** 관계형 데이터베이스는 더 복잡한 종류의 질의를 지원한다. 

이는 복잡한 질의를 여러 실행단계와 파티션으로 분해하며 이들 중 다수는 데이터베이스 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있다.


## 정리

> 저장하고 처리할데이터가 너무 많다면 파티셔닝(샤딩)을 활용하라.

이를 사용하고자 한다면 아래를 고려하자.

- 핫스팟을 방지하라.
- 질의 부하를 여러 장비에 균일하게 분배하라.
- 파티션 재균형화를 진행하라.

### 대표적인 파티셔닝(샤딩) 기법

- 키 범위 파티셔닝

정렬된 키를 기반으로 파티션을 진행한다. 핫스팟이 생길 수 있지만, 조회가 빠르고, 범위쿼리가 쉽다.

- 해시 파티셔닝

각 키에 해시 함수를 적용하고 특정 파티션은 해시값을 담당한다. 범위 질의는 비효율적이지만 핫스팟이 생길 확률이 낮다. 

#### 샤딩을 DB에 라우팅 할지

중간에 주키퍼와 같은 파티션 인지 로드 밸런서를 활용하여 쿼리를 처리한다.



## Ref

- https://catsbi.oopy.io/5f556840-f956-4602-90c0-6bc97b0213a7
