_1장과 2장은 모놀리식 어플리케이션과 MSA, 다양한 데이터베이스 종류 그리고 레디스 설치법에 대해 알려주고있다. 해당 내용은 책의 주제와 상반되니 넘어가도록 한다._

# 3장 레디스의 기본개념

## 레디스의 자료구조

### String

```js
> SET hello workld

> GEt hello
world
```

- NX 옵션을 사용해 키가 없을 때만 새로운 키를 저장할 수 있다.
- XX 옵션을 사용해 키가 있을 때만 새로운 키를 저장할 수 있다.

```js
> SET hellol newval NX
GET hello
world

> SET hello newval XX
> GET hello
newval
```

string형이라고 문자열만 저장할 수 있는것이 아니라 숫자 형태의 데이터도 저장가능하다. `INCR, INCRBY`와 같은 커맨드를 이용하여 `sring`자료구조에 지정된 숫자를 원자적으로 조작할 수 있다.


```js
> SET counter 100
OK

> INCR counter
101

> INCRBY counter 50
151
```

`MSET, MGET`을 활용해 한번에 여러 키를 조작할 수 있다. -> 성능 향상 가능


### List


레디스의 `list`는 인덱스를 가지는 문자열 목록이다. 하나의 리스트에는 최대 약 42억개의 데이터를 저장할 수 있다. 일반적으로 `list`는 서비스에서 스택과 큐로써 사용된다.


- `LPUSH`는 리스트의 왼쪽, `RPUSH`는 리스트의 오른쪽에 데이터를 추가한다.
- `LRANGE`커맨드를 이용해 리스트에 들어있는 데이터를 조회할 수 있다.
   - 파이썬과 동일하게 마지막 인덱스는 -1이다. 
    
```js
> LPUSH mylist E
1

> RPUSH mylist B
2

> LPUSH mylist D A C B A
7

> LRANGE mylist 0 -1 // 순서 유의
A
B
C
A
D
E
B

> LRANGE mylist 0 3
A
B
C
A
```

- `LPOP, RPOP`을 이용해 원소를 삭제할 수 있다. 이는 삭제된 원소를 반환한다.
- `LTRIM`은 인덱스를 인자로 받아 범위에 속하는 원소를 삭제하지만 반환하지 않는다.

> `PUSH, RPUSH, LPOP, RPOP`커맨드는 O(1)로 처리되어 빠른 실행이 가능하다. 하지만 인덱스나 데이터를 이용해 중간 데이터에 접근하는 것은 O(n)만큼 시간이 소비된다.

- `LINSERT`와 `BEFORE`옵션을 활용해 B앞에 E를 추가할 수 있다.
- `LINDEX`커맨드를 사용하여 원하는 인덱스의 데이터를 확인할 수 있다.

```js
> LINSERT mylist BEFORE B E

LRANGE mylist 0 -1
A
E
B
C
D

> LINDEX mylist 3
C
```

### hash

레디스에서 `hash`는 필드-값 쌍을 가지는 아이템의 집합이다. (list와 달리 키값이 키와 대응한다.) 필드와 값 모두 문자열 데이터로 저장된다.

`hash`는 객체를 표현하기 적절한 자료구조이기에 다양한 데이터베이스와 연동되어 주로 사용된다. `noSQL`데이터베이스와 동일하게 새로운 필드에 데이터를 쉽게 저장할 수 있기에 유연한 개발이 가능하다. 

- `HSET`커맨드를 사용하면 `hash`에 아이템을 저장할 수 있으며, 한 번에 여러 필드-값 쌍을 저장할 수 있다.
- `HGET`커맨드를 활용하여 하시 자료구조의 키와 아이템을 가져올 수 있다.
- `HGETALL`커맨드를 활용하여 `hash`내의 모든 필드-값 쌍을 차례로 반환할 수 있다.


```js
> HSET Product:123 Name "Happy Hacking"
1
> HSET Product:123 TypeID 35
1
> HSET Product:123 Version 2002
1

> HGET Product:123 TypeID
35

> HGETALL Product:123
Name
Happy Hacking
TypeID
35
Version
2002
```

![](https://velog.velcdn.com/images/cksgodl/post/91abb5dd-c02b-4583-8b9f-ad04d73dd503/image.png)

### Set

레디스에서 `set`은 정렬되지 않은 문자열의 모음이다. 하나의 자료구조 내에서 아이템은 중복해서 저장되지 않으며, 교집합, 합집합, 차집합 등의 집합 연산과 관련한 커맨드를 제공하기 떄문에 객체 간의 관계를 계산하거나 유일한 원소를 구해야할 경우 사용된다.


- `SADD` 커맨드를 활용하면 아이템을 저장할 수 있다.
- `SMEMBERS`를 활용해 데이터를 확인할 수 있는데, 이때 저장된 순서와 관계없이 랜덤한 순서로 데이터가 출력된다.

```js
> SADD myset A
1
> SADD myset A A A C C B B D D F F
4

> SMEMBERS myset
D
A
C
B
F
```

- `SREM`를 활용하여 `set`에서 원하는 데이터를 삭제할 수 있따.
- `SPOP`커맨드는 아이템 중 랜덤으로 하나를 삭제하고 이를 반환한다.
   - 뭐하는 놈이지
   

- 합집합 연산은 `SUNION`, 교집합은 `SINTER`, 차집합은 `SDIFF`커맨드로 활용할 수 있다.


### sorted Set

스코어에 따라 정렬되는 고유한 문자열의 집합이다.

이는 스코어-값 쌍으로 가지며, 스코어 값으로 정렬돼어 저장된다. 따라서 스코어 값을 통해 O(logn)시간복잡도로 접근이 가능하다.

- `ZADD`명령어로 아이템을 추가할 수 있다.
    - 추가와 함께 정렬된다.
- `ZRANGE`명령어를 통해 범위 검색을 수행할 수 있다.
    - `BYSCORE`옵션을 통해 데이터를 스코어를 통해 조회할 수 있다.
        - 이때는 `ZRANGE score:220817 -inf, inf BYSCORE`와 같이 `inf`를 통해 전체 검색을 할 수 있다.
        
        
```js
ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCROES]
```

> sorted Set은 zSet이라고도 불리운다.


### 비트맵

이는 독자적인 자료구조는 아니고, String자료구조에 bit연산을 수행할 수 있도록 확장한 형태이다. 

`string`자료구조가 `binary safe`하고 최대 512MB까지 저장할 수 있기에 2의 32승만큼 비트를 저장할 수 있다.

- `SETBIT`연산자를 통해 비트를 저장할 수 있으며, 
- `GETBIT` 커맨드로 저장된 비트를 조회할 수 있다.
- `BITCOUNT`를 통해 1로 설정된 비트의 개수를 카운팅할 수 있다.


### Hyperloglog

집합의 원소 개수인 카디널리티를 추정할 수 있는 자료구조이다.

### Geospatial

위치 정보를 저장할 수 있다. (경도 위도 기반)

거리 측정 함수도 내장하여 제공한다.

### Stream

레디스 메시지 브로커로써 활용할 수 있게끔 만듬 자료 구조이다. 

## 레디스에서 키를 관리하는 방법

레디스의 키의 생성과 삭제는 아래 세가지 공통적인 규칙을 따른다.

1. 키가 존재하지 않을 때 아이템을 넣으면 아이템을 삽입하기 전에 빈 자료 구조를 생성한다.

  저장하고자 하는 키에 다른 자료 구조가 이미 생성돼 있으면 에러를 반환한다. `WRONGTYPE Operation against a key holding the wrong kind of value`

2. 모든 아이템을 삭제하면 키도 자동으로 삭제된다.

3. 키가 없는 상태에서 키 삭제, 아이템 삭제, 자료 구조 크기 조회 같은 읽기 전용 커맨드를 수행하면 에러를 반환하는 대신 키가 있으나 아이템이 없는것처럼 동작한다.

## 키와 관련된 커맨드

- EXSITS

키가 있는지 확인하는 커맨드다 있으면 1, 없으면 0을 반환한다.

- KEYS

레디스에 저장된 모든 키를 조회하는 커맨드다. 매칭되는 패턴에 해당하는 모든 키의 `list`를 반환한다.

> `KEYS`는 상당히 위험한 커맨드다.
> 
> 100만 개의 키가 저장되어 있으면 모든 키를 순회하면서 작동한다. 레디스는 싱글 스레드로 작동하기 때문에 실행 시간이 오래 걸리는 커맨드를 수행하면 다른 클라이언트에서 들어오는 커맨드가 차단된다. 
>
> 따라서 아래 나오는 `SCAN`커맨드를 활용할 것을 권장한다.


- SCAN

커서 기반으로 특정 범위의 키만 조회할 수 있다.

`MATCH`옵션을 통해 키값을 필터링할 수 있는데 이는 범위의 모든 키를 읽고 필터링 하는 방식으로 진행된다. 따라서 키가 반환되지 않거나 적은 수의 키만 반환될 수 있다.

다른 자료구조형에서 사용할 수 있는 `SSCAN, HSCAN, ZSCAN`이 있다. (각각 set, hash, sorted set에 사용가능하다.)

- SORT

`List`자료구조의 레디스 아이템을 정렬한다. 숫자, 문자열 다 정렬 가능하다.

- RENAME / RENAMENX

키의 이름을 변경한다.

- OBJECT

키의 상세 정보를 반환한다.

- FLUSHALL

케디스에 저장된 모든 키를 삭제한다. 

- DEL

키와 키에 저장된 모든 아이템을 삭제한다.

- UNLINK

키와 데이터를 모두 삭제하는 커맨드이다. 하지만 이 커맨드는 백그라운드 쓰레드에 의해 다른 스레드에서 처리되며, 키와 연결된 데이터의 연결을 끊는다.

이는 키 하나에 100만개의 아이템이 들어있을 때 `DEL KEY`를 하면 100만개의 키를 `flushall`하는것과 동일하기에 이런 경우 `UNLINK`를 활용하는 것이 좋다.

- EXPIRE

키가 만료될 시간을 초 단위로 지정한다.

- EXPIREAT

유닉스 타임스탬프에 만료될 수 있도록 시간을 지정한다.

- EXPIRETIME

키가 삭제되는 유닉스 타임스탬프를 초단위로 반환한다.

- TTL

키가 몇 초 뒤에 만료되는지 반환한다. (-1은 무한히 살아남는다.)


# 5장 레디스를 캐시로 사용하기

왜 레디스를 캐시로 사용하는가?

- 키-값 형태를 활용함으로써 간단하다.
- 인메모리 저장소이기 때문에 빠르다.
- 고가용성이다.(클러스터 샤딩 등을 제공받을 수 있다.)

## 캐시전략

### look aside

주로 많이 사용되는 전략으로 레디스를 찌르고 없다면 데이터베이스를 찌른다.

![](https://velog.velcdn.com/images/cksgodl/post/7a28b227-4810-47d4-91ac-668748c21c11/image.png)

찾고자 하는 데이터가 없을때만 레디스에 값이 저장되기에 `lazy loading`이라고 불리우기도 한다. -> 이에 따라 초기 실행시에는 웜업과정을 거치는 것을 추천한다.

### 캐싱의 일관성 문제

원본 데이터베이스가 변경될 떄 레디스는 이전값을 가지고 있을 수 있다. 이를 캐시 불일치라고한다.

- write through

![](https://velog.velcdn.com/images/cksgodl/post/7044d864-8877-4912-a968-c3c68d040109/image.png)


간단하게 말하면 더블라이트가 값이 변경될 떄마다 레디스 및 원본데이터에 두번 업데이트 한다. (이 방식을 사용할 경우 TTL설정을 권장)

- cache invalidation

이는 원본 데이터베이스에 값을 업데이트할 떄 마다 캐시값을 삭제한다. 리소스를 적게 사용하기에 유용하다.

- write behind

![](https://velog.velcdn.com/images/cksgodl/post/ce8e87df-46a6-4a14-a479-d5e5f684e6fb/image.png)

디스크에 I/O작업이 대량으로 발생하면 원본 데이터베이스 성능저하가 발생할 수 있다. 따라서 건수나 특정 시간 간격등에 따라 비동기적으로 데이터베이스를 업데이트 하는 방식이 있다.

데이터 업데이트는 캐시에 모두 없데이트하고, 주기적으로 데이터베이스에 이를 write한다.

## 캐시에서의 데이터 흐름

### TTL 삭제방식

레디스는 키가 만료되었다고 바로 메모리에서 삭제되는 것은 아니다. 키는 `passive` 방식과 `active`방식 이 두가지로 삭제된다.

- Passive 방식 : 클라이언트가 키에 접근하고자 할 때 키가 만료되었다면 수동적으로 삭제한다. 

- Active 방식 : TTL값이 있는 키 중 20개를 랜덤하게 뽑아낸 뒤, 만료된 키를 모루 메모리에서 삭제한다. 만약 25%이상의 키가 삭제되었다면 다시 20개의 키를 랜덤하게 뽑은 뒤에 확인하고, 아니라면 뽑아놓은 20개의 키 집합에서 다시 확인한다. 이러한 과정을 1초에 10번씩 수행한다.

### 메모리 관리와 maxmemory-policy 설정

레디스 키에 만료 시간을 설정해 데이터가 자동으로 삭제되도록 할 수 있다. 하지만 최대 메모리 설정 및 `maxmemory-policy`를 통해 메모리를 관리할 수도 있다.

#### Noeviction

레디스 메모리관리의 기본 값이다.

레디스에 데이터가 가득 차더라도 임의로 데이터를 삭제하지않고, 에러를 반환한다. 관리자가 레디스를 직접 지워야 하기때문에 레디스를 캐시로 사용할 때 권장하지 않는 설정값이다.

#### LRU eviction

`LRU`알고리즘을 활용하여 최근에 사용되지 않은 데이터부터 삭제한다. 레디스는 이와관련되서 2가지 설정을 제공한다.


- `volatile-LRU` : 만료시간이 설정돼 있는 키에 한해서 키를 삭제한다.
- `allkyes-LRU` : 모든 키에 대해 메모리가 키를 삭제한다.

#### LFU eviction

자주 사용되지 않는 데이터부터 삭제한다.

이또한 만료시간에 따른 설정을 제공한다.

> 레디스에서 키를 삭제하기 위해 사용되는 LRU, LFU알고리즘은 모두 근사알고리즘으로 구현된다. 따라서 성능측정이 필요하다.

#### RANDOM eviction

랜덤으로 키를 삭제한다. 키를 따로 계산하지 않기에 부하가 가장 적지만, 성능이 좋지 않을 수 있다.


#### volatile-ttl

만료 시간이 가장 작은 키를 삭제한다. 즉, 삭제 예정 시간이 얼마 남지 않은 키를 추출해 해당 키를 미리 삭제하는 옵션이다.

### 캐시 스탬피드 현상

![](https://velog.velcdn.com/images/cksgodl/post/822bd77e-28b6-4d5c-ab2f-19f8f7116335/image.png)

`MSA`환경에서 일어날 수 있는 문제로써 위의 그림처럼 데이터베이스를 중복으로 읽어고고, 캐시에 중복으로 쓰는 과정을 의미한다.


### 세션 스토어로서의 레디스

관계형 데이터베이스를 활용할 수도 있지만, 일반적으로 레디스를 활용하여 세션스토어를 구현한다. (O(1)로 접근이 가능하기에)

레디스의 `hash`자료구조를 활용해 세션 데이터를 저장할 수 있다.

- `usersession:1`
- `usersession:2`
- `usersession:3`

### 캐시와 세션의 차이

캐시와 세션은 비슷해보이지만 데이터를 읽고 쓰는 패턴이 다르다.

레디스를 캐시로 사용할 때의 가장 일반적인 패턴으로 `look aside`전략을 이용한다.

![](https://velog.velcdn.com/images/cksgodl/post/9454beb9-9809-43bc-b451-c87229ea790c/image.png)

위의 그림과 같이 캐시는 데이터베이스의 완벽한 부분집합으로 이루어진다. 캐시의 데이터가 소멸되어도 해당 데이터는 데이터베이스에서 찾을 수 있다.

하지만 세션 데이터는 여러 사용자간에 공유되지 않으며, 특정 사용자ID에 한해 유효하다.

1. 세션이 시작될 때 데이터베이스에서 유저 데이터 로드
2. 세션 활성화 중에는 데이터베이스가 아닌 세션 스토어를 통해 유저 데이터 관리
3. 세션이 만료될 때 원본 데이터베이스에 유저 정보 업로드

위의 예로써 최근 봤던 아이템, 장바구니에 담긴 아이메은 세션이 열리며 레디스에 저장되며 유저가 로그인을 끝냈을 때야 데이터베이스에 저장되게 된다.

> 주의 : 세션 스토어에 장애가 발생하면 내부 데이터가 손실될 가능성이 있으므로, 신중한 운영이 필요하다.











