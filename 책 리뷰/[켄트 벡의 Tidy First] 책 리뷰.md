![](https://velog.velcdn.com/images/cksgodl/post/d4364898-2e51-483c-801f-690ff8fd809c/image.png)

# 책 리뷰

책의 본문은 150페이지가 넘지 않는 아주 작은 책이다. 본문과 함께 옭긴이가 켄트 벡과 질의응답을 한 책이 하나 더 있다. (세트 22,000원) 

`Tidy First?`에서 `Tidy`는 정돈하다라는 뜻이다. 즉 책의 제목은 `코드정리를 먼저 해야할까?`정도로 해석이 가능할 것 같다. 책은 제목과 동일하게 크게 3부분으로 나뉜다.

- 코드 정리법
  코드를 정리하는 방법과 정리하게 쉽도록 작성하는 법 
- 관리
  코드 정리를 언제 어느정도 해야하는가?
- 이론
  코드가 정리되는 이론 및 코드정리의 가치를 경제적으로 정리

책의 난이도는 종합적인 편이다. 초반은 쉬우며 후반으로 갈 수록 이해하기 어려워지며 켄트 백의 소프트웨어 설계로써의 안목을 엿볼 수 있다. 개인적인 생각으로는 주니어에게는 그나마 코드 정리부분이 도움이 될 것 같으며, 시니어 및 연차가 쌓인 개발자에겐 관리 및 이론 파트가 도움이 될 것 같다.

> "Make the change easy, then make the  easy change"
>
> 변화를 쉽게 만들고, 그 다음에는 쉽게 변화하라.

책의 내용은 정리하자면 위와 같다. 해당 아래 요약을 한번 보면 왜 이렇게 이야기했는지 알 것 이다.

---

아래는 책 내용의 정리이다.

# 01. 코드 정리법

_책의 일부 예시코드를 Kotlin으로 바꿔서 정리하였음_

## 보호 구문

- 브런치 문을 작성할 때 `depth`를 늘리지 말 것

```kotlin
// X
if (조건 1) 
	if (조건 2)
    	return

// O
if (조건 1) return
if (조건 2) return
```

- 브런치 문 내부에 많은 코드를 넣지 말 것

```kotlin
// X
if (조건)
	...루틴의 나머지 코드...

// O
if (조건)
    ... 코드 일부분...
... 다른 코드
```


> **항상** 그리고 **반드시** 작은 단계를 거쳐 코드를 정리하라.


## 안 쓰는 코드

지워라.

지워도 커밋 로그에 남는다.

## 대칭으로 맞추기

팀원과의 코드를 대칭으로 맞추어 활용하라.

```kotlin
// Null체크를 let, if문으로 하는 각각의 예제
someObject?.let {
	// ...
}

if (someObject == null) {
	// ...
}

// Log를 찍는 예제
val someData = "someData"
log.info { "$someData is Data" }

val someData = "someData".also {
	log.info { "$it is Data" }
}

// Validate 판별
class SomeClass() {
    init {
    	validtate(this)
    } 
}

val someClass = SomeClass().also {
	validate(this)
}
```

팀원과의 코드조율을 통해 한 가지 방식을 선택하여 사용하라. 이는 코드 스타일 뿐만 아니라 네이밍에도 적용되는 이야기다.

## 새로운 인터페이스로 기존 루틴 부르기

새로운 기능을 추가하고자 한다면, 되도록 기존 인터페이스를 더럽히지 말고, 새로운 인터페스를 추가하라. 

이를 "통로 인터페이스"라고 하며, 어떤 동작을 변경해야할 때 변경을 쉽게 만들어 준다.

복잡하다면 아래의 설계를 활용하라.

- TDD 설계
- 거꾸로 설계
   - 루틴의 마지막 줄부터 시작한다. (TDD와 동일)
- 도우미(helper) 설계
   - helper를 활용하여 특정 로직을 수행하도록 변경한다.
      - 특정 작업을 수행하는 도메인 클래스를 확장하라.
   
## 읽는 순서

코드의 진행 순서대로 코드를 배치하라.

코드를 읽는 독자라고 생각하고, 코드의 순서를 배치하라. 이는 주관적이기에 정답은 없다.
- 기본 요소를 먼저 이해한 다음 다음 구성 방법을 이해할 것인지
- API를 먼저 이해한 다음 세부 구현을 이해하고 싶은지

## 응집도를 높이는 배치

구조 및 결합도에 맞도록 디렉토리, 모듈, 레포지토리를 구현하라. 코드에서도 함수를 응집도 있게 배치하나, 결합도는 낮추어라

> 결합도 제거 비용 + 변경 비용 <-> 결합도에따른 비용 + 변경비용

사이에 따른 비용을 고민하고, 적절한 시 기에 적절하게 결합도를 제거하라.

- 응집도를 높이는 순서로 정리하면 코드를 더 쉽게 변경할 수 있다.


## 선언과 초기화를 함께 하라

아래와 같이 선언과 초기화를 동기에 함께하라 그리고 코드를 사용하는 곳 바로 근처에서 변수를 선언하라.

```kotlin
val a = 10
// a를 사용하는 코드
val b = 50
// b를 사용하는 코드
```

> 여담)
>
> _"변수와 변수에 값을 채우는 코드들의 순서를 이전 그대로 둘 수는 없습니다."_라고 책에서는 표현한다. 코틀린에서는 변수에 값을 채우는 행위를 아예 추천하지 않는다. 
> 
> `var`을 사용하는 것을 권장하지 않기도 하며 값을 채우는 행위를 진행하더라도, `lazy`, `lateinit`등의 방법으로 어떤 값을 미리 채우는 방식으로 진행한다.


## 설명하는 변수

코드는 점점 커진다. 따라서 함수 및 변수의 동작은 변할 것이며, 이에 따른 이름은 수시로 바꾸어라. 

또한 동작에 대한 커밋과 코드 정리에 대한 커밋을 분리하라.

- style : ...코드 정리...
- feat, fix, refactor : ...동작에 대한 커밋...

또한 아래 예제와 같이 표현식의 의도가 드러나도록 변수 이름을 만들어 할당하라.

```kotlin
// Worst
return Point(
	...긴 표현식...,
    ...다른 긴 표현식...
)

// Better
x = ...긴 표현식...
y = ...다른 긴 표현식...
return Point(x, y)

// Best
return Point(
	x = ...긴 표현식...,
    y = ...다른 긴 표현식...
)
```

> 다른 언어에서는 `Named Argument`를 제공하지 않기에 변수를 할당해서 의도를 표현해야하지만, 코틀린에서는 그럴 필요가 없다.


## 설명하는 상수

상수는 추출하라. 책에서는 아래와 같이 표현한다.

_상징적인 상수를 만드세요. 리터럴 상수로 사용된 곳은 상징적인 상수를 차출합니다._

```kotlin
object EventId {
    const val VIEW = 1
    const val CLICK = 2
    const val VIEWABLE = 3
    const val CALL = 4
    const val ERROR = 5
}

// 빈약한 의미의 상수 추출 X
const val ONE = 1
```

> 같은 맥락의 상수는 `object`를 통해 인스턴스를 생성하는 것을 권장한다. 최상위 변수로 선언하여 활용하여도 되지만, 이는 찾기 힘들고 메모리 생성관점에서 해당 파일의 이름에 따른 자바 클래스를 또 생성한다.

## 명시적인 매개변수

JS의 경우 개발하다보면 `God Parameter`를 만들어 본 적 있을 것이다.

```javascript
param = { a: 1, b: 2, c: 3, .... }
poo(param)

function poo(params)
	...params.a 코드... 
    ...params.b 코드...
```

이런 경우 `DTO`를 만들더라도 나누어 사용하라.

```kotlin
data class ChildrenDataInterface(
    val id: ObjectId,
    val name: String,
    // ...
) {

	fun toParent(): ParentDataInterface = ParentDataInterface(
        id = this.id,
        name = this.name,
    )
}
```

이렇게 활용하는 편이 가독성, 테스트, 분석면에서 요이하다.


## 비슷한 코드끼리 빈줄로 구분

긴 코드 덩어리를 읽다가 작동되는 기능이 구분되거나 논리가 구분되면 두 부분사이에 빈 줄을 넣어 분리하라.

소프트웨어 설계는 복리이자와 동일하다. 정리함으로써 얻는 이득은 많고, 깨진 유리창이 되지 않게 조심하라.


```kotlin
fun main() {
	...a 로직...
	
    ...b 로직...
	
    ...c 로직...
}
```

## 도우미 추출

코드 중 목적이 분명하고, 나머지 코드와 상호작용이 적은 코드라면 `helper`로 추출하라. (이 때 도우미이름은 작동 방식이 아니라 목적에 따라 네이밍한다.)

_이는 메서드 추출과 동의미이다._

```kotlin
fun main() {
	doA()
	
	doB()
	
	doC()
}
```

## 하나의 더미

코드가 지나치게 많은 함수로 나뉘어져 있을 때는 코드를 하나의 더미(`One Pile`)처럼 느껴질 떄 까지 모아라. 그리고 다시 정리하라.

__코드를 만드는 데, 가장 큰 비용이 들어가는 일은 작성이 아니라 읽고 이해하는데 드는 비용이다.__

> 코드를 모음으로써 응집도를 높일 수 있지만, 실무적으로는 가독성을 증가시킬 수 있다.

메서드 분리의 목적은 가독성의 증가도 있다. 명확성을 찾으려면 코드를 모으는 것을 고려해보아라. 

아래의 증상이 느껴진다면 코드를 모으는 것을 검토해보아라.

- 길고 반복되는 인자 목록
- 반복되는 코드, 그 중에서도 반복되는 조건문
- 도우미에 대한 부적절한 이름
- 공유되어 변경에 노출된 데이터 구조

_"작은 함수 속에 코드를 이해하고자 갖은 애를 쓰다가 문득, 자신의 능력을 의심하는 데까지 이르기도 한다. 하지만, 이때 코드를 한곳으로 모으면 모든것이 이해되기 시작한다."_

## 설명하는 주석

클린코드 및 여타 다른 책에서는 주석을 제거하는 것을 권장한다. 하지만 가독성을 올릴 수 있는 주석이라면 주석을 작성하는 것을 권장한다.

_"코드를 읽다가 '아, 이건 이렇게 돌아가는 거구나!"라는 생각이 드는 순간아시죠? 바로 그 순간 주석을 작성해보세요"_

## 불필요한 주석 지우기

설명하는 코드를 작성하도록 노력하라.

- 중복되는 주석
- 가독성을 저하시키는 주석
- 유지보수가 안될것 같은 주석
- 코드와 중복되는 주석

을 삭제하라.

# 02. 관리

2장에서는 코드 정리를 개발 흐름에 맞추는 방법에 대해 설명한다.

- 코드 정리는 언제 시작하는지?
- 코드 정리는 언제 멈추는지?
- 코드의 구조를 변경하는 코드 정리와 시스템 동작 변경을 어떻게 결합할 수 있을지?

## 코드 정리 구분

__코드 정리는 별도의 PR로 구분하고, 가급적 PR당 몇 개의 코드 정리만 넣어라.__

_변경 사항을 나누어 별도의 PR로 만들어야 한다. (심지어 하나의 정리만 있더라도) 동작 변경 역시 별도의 PR로 만든다. 코드 정리와 동작 변경 사이를 번갈아 가면서 전환할 때 마다 새 PR을 열어야 한다._

작은 PR은 리뷰가 빠르게 진행되며, 변화를 쉽게 만든다.

> 여담
>
> 코드의 가독성과 동일하게 PR또한 가독성이 중요하다. 단 한줄의 코드 정리라도 별도의 PR로 만드는 것이 과연 가독성을 위한 일인가?
>
> 팀원의 개발자가 개발을 하다가 `Context Switching`을 통해 PR을 하러 오는 비용을 비교해 보아라. 하던 것을 모두 멈추고 왔는데 한줄의 `PR`이면 어떻겠는가. 

## 연쇄적인 정리

코드 정리는 자꾸 손이 가는 감자칩과 같다. 점점 많은 코드를 정리하고 싶어지는데, 책의 저자는 아주 작은 단계부터 시작하는 것을 권장한다.

아주 작은 단계란 무엇을 의미하는가? 함수 하나, 클래스 파일 하나를 의미할 수도 있지만, 저자는 행위를 단계로 나눈다. 여기서 행위란 1장에서 설명한 코드 정리 기법을 의미한다.

- 보호 구문
- 안 쓰는 코드
- 대칭으로 맞추기
- 새로운 인터페이스로 기존 루틴 부르기
- 읽는 순서
- 응집도를 높이는 배치
- 설명하는 변수
- 설명하는 상수
- 명시적인 매개변수
- 비슷한 코드끼리
- 도우미 추출(메서드 추출)
- 하나의 더미
- 설명하는 주석
- 불필요한 주석 지우기

코드 구조를 대대적으로 바꾸려고 하지 말고, 너무 많이, 너무 빠르게 변경하지 않도록 주의하라. 

_(PR -> 보호 구문, 안쓰는 코드 정리 PR)_

## 코드 정리의 일괄 처리량

코드 정리의 범위를 판단할 때 고려할 만한 비용은 다음과 같다.

![](https://velog.velcdn.com/images/cksgodl/post/76723fbe-afd5-4338-8e4e-a5cc42c5b32f/image.png)

- 충돌
일괄 처리하는 코드 정리 작업이 많을수록, 통합 과정에서 지연 시간이 길어지고. 다른 사람의 진행 작업과 충돌할 가능성도 커진다.

- 상호작용
다수의 코드 정리를 하다가 우연히 동적 변경을 할 수도 있다. (사이드 이펙트)
또한, 코드 정리 사이에 상호작용이 있으면 병합 비용이 커진다.

- 추측
한 번에 처리하는 코드 정리가 많을수록 더 많은 코드를 정리하게 된다. 이로 인해 추가 비용이 발생할 수 있다.

__코드 정리 비용을 줄이고자 한다면, 저 자주, 더 많이 코드 정리 PR을 작성하라. 그에따라 동작 변경에 소용되는 비용이 줄어들 수 있다.__

## 리듬

> __코드 정리는 몇 분에서 한 시간 이내로 걸리도록 하라.__

이보다 더 오래걸려도 괜찮다. 이후의 코드 정리는 점점 짧아질태니까. 또한 동작의 변경 PR이 전에 코드 정리를 선행하는 것을 권장한다. 이런 과정을 여러번 거치고 나면 _"이미 정리를 끝낸 코드로 동작 변경을 하고 싶어하는 자신을 발견할 수 있다."_

동작 변경은 코드 안에 뭉쳐서 나타나는 경향이 있다. 파레토 법칙에 따르면 80%의 변경 사항이 20%의 파일에서 발생한다. 코드 정리를 선행할 때 얻을 수 있는 장점은 코드 정리도 뭉쳐져 정확하게 동작 변경하기 좋은 위치가 될 수 있다.

__코드 정리를 꾸준히 한다면 대부분의 변경 작업은 이미 정리된 코드 안에서 이뤄진다.__


## 얽힘 풀기

다들 메소드를 추출하고, 코드를 정리하다가 동작을 변경해야할 상황에 도착한 적이 있을 것이다.

이럴 땐 진행 중인 작업을 버리고, 코드 정리를 선행하는 순서로 다시 시작해보자. 작업은 더 많아지지만, 이어지는 커밋과의 일관성은 분명해질 것이다. 

> __이런 코드 정리(얽힘 풀기)는 얽혀 있다는 것을 깨달았을 때가 바로 적기이다.__

## 코드정리 시점

코드 정리는 언제하면 좋을까? 코드 정리를 하는 기준을 몇 가지 제시한다.

- 코드 정리하는 데 드는 시긴과 지금 추가할 기능에 드는 시간이 비슷할 때
- 지금 코드를 완전히 이해하고 있고, 지금 정리하는 것이 더 저렴할 때
- 코드 정리를 하고 싶은 기분일 때
   - 이때 하면 더 의욕적이고 기분도 좋다.   

그러나 아래와 같은 상황에는 코드 정리를 하지 않는 것을 추천한다.

- 앞으로 다시는 코드를 만질일이 없을 때
- 설계를 개선하더라도 배울 점이 없을 때
- 분량이 너무 많은데 보상이 바로 보이지 않을 때
- 작은 묶음으로 나눠서 정리할 수 있을 때


# 03. 이론

이전장까지 언제, 어떻게 정리해야 하는지 알았으니, 3장에서는 그래서 왜 코드를 정리해야 하는지 알아본다. 이런 이론을 이해하면 효율적으로 소프트웨어 설계가 가능하다.

## 요소들을 유익하게 관계 맺는 일

> 저자는 효율적인 소프트웨어 설계를 __요소들을 유익하게 관계 맺는 일__이라고 칭한다. 

### 요소

현실 생물은 아래와 같이 형성된다.

- 세포 -> 기관 -> 유기체

소프트웨어는 현실의 추상화 버전이며, 프로그래밍은 아래와 같이 구성된다.

- Token -> Expression -> Statement -> Function -> Object -> System

이들을 우리는 __요소__라고 한다.

### 관계 맺기

자연에서는 "염소가 풀을 먹는다"라는 관계가 있듯, "한 함수가 다른 함수를 호출한다."라는 관계를 맺는다. 위에서 설명한 계층구조의 요소들이 서로 관계를 맺는다. 소프트웨어에서의 관계는 아래와 같은 4종류로 나뉜다.

- 호출
- 발행
- 대기
- 참조(변수 값 가져오기)

### 유익하게

마법이 일어나는 단계이다. 하나의 설계 작업은 작은 하위 요소로 만든 거대한 수프를 만드는 것이다. 스프링 프레임워크를 생각해보자. 외부 관찰자의 입장에서는 그저 잘 설계된 프레임워크로 동작하지만, 내부 동작을 빠르게 변경할 수는 없다. 잘 드러나지 않는 관계가 너무 많기 때문이다.

유익하다는 것은 이런 큰 프로그램(프레임워크 등) 내부의 요소들의 관계를 통해 큰 프로그램의 복잡한 부분을 나눠 가지는 것을 의미한다.

### 요소들을 유익하게 관계 맺는 일

소프트웨어 설계자는 다음과 같은 일만할 수 있다.

- 요소를 만들고 삭제한다.
- 관계를 만들고 삭제한다.
- 관계의 이점을 높인다.

위의 3가지 단계만 효율적으로 수행해도 훌륭한 소프트웨어 설계자가 될 수 있다.

> 잡담
>
> 책을 읽으며 생각하는 것은 이 책은 주니어가 읽기엔 너무 사기꾼같은 책이다. 실무와 너무 멀게 느껴지지도 않고, 내부 설명을 읽다보면 개발자 즉, 소프트웨어 설계자가 너무나도 간단하게 느껴진다. 아는 만큼 보이는 책이기에 모든 내용을 흡수하기보단 적당하게 아는 만큼만 보고 넘어가자.


## 구조와 동작

소프트웨어는 두 가지 가치를 추구한다.

- 현재 소프트웨어가 잘 동작하게 하는 것
- 미래에 새로운 일을 시킬 수 있는 변화의 가능성을 놓지 않는 것

두개 다 중요하지만, 

> 미래에 새로운 일을 시킬 수 있는 변화의 가능성의 폭을 넓히는 것 을 중요하게 생각하라.


---

시스템을 더 가치있게 만들기 위해 시스템의 동작을 바꿀 필요는 없으며, 할 수 있는 선택의 기회를 더 만드는 것이 도움이 된다. **환경의 변동성이 클 수록 옵션의 가치는 더 커진다.** 책 앞단에서 말했 듯 `변화를 포용하고, 쉽게 변화하라.`라는 책의 주제를 다시 생각해 볼 것


## 경제 이론 : 시간 가치와 선택 가능성

- 오늘의 1달러는 내일의 1달러보다 더 가치 있기에 빨리벌고, 쓰는 것은 뒤로 미룬다.
- 혼란스러운 상황에서는 어떤 물건에 대한 옵션이 물건 자체보다 낫기 때문에 불확실성에 맞서는 옵션을 만든다.
   - 특정 환경에 고착화된 생물은 환경이 변화하면 모두 멸종한다. 황소개구리를 보아라. 한국의 혹독한 사계절에도 모두 적응하는 환경(기온 적응, 피부, 먹이)를 가지고 있다.
   
> 소프트웨어는 현실의 추상화 버전이다. 따라서 "먼저 벌고 나중에 써야 한다."와 "변화할 수 있는 옵션을 만들어야한다."라는 두 가지 속성을 조화시켜야 한다.
   
## 오늘의 1달러가 내일의 1달러보다 크다.

"오늘의 소프트웨어 시스템은 내일의 시스템보다 더 가치있다."라는 관점이 아니다. 아래 예제를 보자.

- 10년 동안 1천만 달러의 비용을 들여 2천만 달러를 버는 시스템
- 지금 1천만 달러를 벌고, 10년뒤에 2천만 달러를 지불한다.

전자는 10년동안 1천만 달러의 비용에 대한 수익을 얻기 위해 긴장해야 한다. 하지만 후자의 경우는 첫날 부터 수익이 보장되기에 앞으로의 미래가 기대된다.

> 이 책에서는 돈의 시간 가치는 코드 정리를 먼저 하기보다는 나중에 하는 것을 권장한다.

지금 당장 기능을 추가하여 돈을 벌고, 나중에 코드를 정리하여 돈을 쓰는 것이다. 이는 정확한 예는 아니지만, 적어도 실패율이 낮은것은 확실한, 돈은 무조건 버는 방식이다. 

_아예 코드 정리를 하지 말라는 것은 아니다. 그래도 코드를 정리하지 않고 동작 변경을 하는 경우가 더 비쌀경우는 코드를 정리하라._

## 옵션

위의 내용을 정리하면 아래와 같다.

- 더 많이, 더 일찍, 더 높은 확률로 돈을 벌기
- 더 적게, 더 늦게, 더 낮은 확률로 돈을 지출하기

이러한 옵션을 소프트웨어에 어떻게 적용할 지도, 또한 소프트웨어 설계자로써 이로한 옵션을 염두해두고 일하는 것은 쉽지 않다. 아래는 켄트백이 실무자로 일하면서 경험했던 교훈은 아래와 같다.

1. "다음에 어떤 동작을 구현할 수 있을까?" 고민하기.
동작을 구현하기 전에도, 그 자체로 가치가 있다. 우리는 지금까지 한일에 대한 대가를 받는 것이 아니라, **다음에 할 수 있는 일에 대한 대가를 받고 있는 것이다.**

2. "다음에 어떤 동작을 구현할 수 있을까?"
라는 질문은 동작 후보 목록이 많을 수록 더 가치있다. 자신의 포트폴리오에서 이사람이 할 수 있는 일이 많을 수록 몸값이 비싸지는 것과 동일하다.

3. 가치에 대한 예측이 불확실할 수록 구현하는 것보다 옵션이 지닌 가치가 더 커진다.
변화를 포용하면 창출한 가치를 극대화할 수 있다. 이점이 통상적으로 소프트웨어 개발이 가장 성공하는 지점이다.


> 오늘 우리가 하는 설계는 내일의 동작 변경을 구매하는 옵션에 대해 지불하는 프리미엄이다. 적절한 설계와 고민을 통해 소프트웨어를 설계하라.

## 되돌릴 수 있는 구조 변경

이는 `가역성`이라고도 한다.

기능 추가는 간단하게 되돌릴 수 있다. 하지만 코드 정리는 되돌리기가 쉽지 않다.(엮여있는 모든것을 다시 바꿔야 함) 따라서 코드 정리는 아래와 같이 고려해 진행해야 한다.

1. 이 결정이 확산될 가능성이 있는 결정인가?
2. 그런일이 발생하면 한번에 하나씩 정리해 가기

> 아주 작은 것 사소한것 부터 되돌릴 수 있도록 구조 변경을 진행하자.

## 결합도

"한 요소를 변경하면 다른 요소를 변경해야 한다." 이를 결합도 라고 한다. 단, 이름을 바꾸거나, default아규먼트를 추가하는 등의 변경은 결합되어 있다고 보지 않는다.

가끔 강하게 결합되어 있는 여러 코드를 볼 때 "내가 이것을 바꾸면, 저것들 모두 바꿔야 하잖아. 너무 끔찍해"라며 마음이 흔들릴 떄가 있다. 이땐 시간을 내어 코드 정리 카탈로그를 살펴보고, 어떤 것이 결합도를 최대한으로 줄일 수 있는 방향인지 고민해 보아라.

> 결합도를 효율적으로 줄일 수 있는 방향을 고민하라.

## 콘스탄틴의 등기성

소프트웨어의 개발 비용의 70%는 유지보수 비용이다. 이 유지보수 비용을 줄이기위한 방법이 무엇일까

소프트웨어의 누적비용은 변경비용과 크게 관리있으며, 큰 다섯 개의 변경이 작은 만 개의 변경보다 더 큰 비용을 유발한다. (대부분의 경우) 이렇게 변경은 변경을 전파하고, 이런 변경은 자동으로 결합도와 연관되게 됩니다. 

> 비용(소프트웨어) ~= 결합도
>
> 결합도는 비용과 직결된다. 따라서 소프트웨어 비용을 줄이려면 결합도를 줄여라.

## 결합도와 결합도 제거

결합도를 바로 깨닫는것은 쉽지 않다. 장애가 일어나거나, 새로운 기능추가를 해야할 때 결합도를 느끼게 된다. 

한 종류의 코드 변경에 대한 결합도를 줄일수록 다른 종류의 코드 변경에 대한 결합도가 커진다. 이말은 즉슨, 모든 결합을 색출하듯 없애려고 애쓰지 말아야 한다. 이는 결합도 제거 비용과 관련이 있다.

> 결합도와 결합도 제거 비용은 수요와 공급 그래프와 동일하다.
>
> 결합도를 증가시키면 결합도 제거 비용이 늘어나고, 결합도 제거 비용을 증가시키면, 결합도가 감소한다.

![](https://velog.velcdn.com/images/cksgodl/post/40ccaab9-50db-4f6b-8986-a6a014de220d/image.png)


## 응집도

결합된 요소들은 둘을 포함하는 같은 요소의 하위 요소여야 한다.

메소드 추출 또는 클래스, 인터페이스 분리를 통해 결합되지 않은 요소들을 각각 다른 곳에 배치하는 작업을 수행해라. (소프트웨어 설계자가 되어라) 이에 따라 응집도가 증가하게 되고, 분석과 변경이 쉽고, 우발적인 동작 변경에 대한 가능성도 줄어든다.

즉흥적으로 많이 시도하지는 말고, PR을 보낼 때 한 번에 한 요소씩만 이동하게 하라.  초기 보았을 때 보다 더 나은 상태로 남겨두는(스카우트 법칙)을 따라라.


## 결론

코드 정리에 대해 알아보았고, 코드정리의 아래 네가지 의문을 생각하라.

- 코드를 정리하면 비용이 주는가? or 줄일 가능성이 있는가?
  - OK -> 노력대비 가성비가 나오는가?
- 코드를 정리하면 수익이 더 커지는가? or 더 빨리 수익이 발생하는가?
- 결합도 : 코드를 정리하면 변경에 필요한 코드가 줄어드는가?
- 응집도 : 코드를 정리하면 변경을 더 작고 좁은 범위로 집중시킬 수 있는가?
- __코드를 정리하며 당신이 평화와 만족, 기쁨을 느낄수 있겠는가?__

_사실 코드를 어느정도 작성한 개발자라면 마지막 요소를 느낄 때 결합도가 낮아지고, 응집도가 높아지는 경향이 있다._

최상의 상태에서 최상의 코드와 같이 일할 때 더 나은 개발자가 될 수 있다. 하지만, 코드 정리에 너무 집착하지는 말아라. 코드를 작성하고 머지하는것은 나뿐만 아니라 팀원의 몫도 있기에 이를 생각할 것 

그래도 이런 팀원을 배려하기 위해서는 가장 중요한 것이 코드를 변화에 쉽게 대응하도록 작성하는 것이다. 다시한번 언급하자면 아래와 같다.

> "Make the change easy, then make the easy change"
>
> 변화를 쉽게 만들고, 그 다음에는 쉽게 변화하라.

